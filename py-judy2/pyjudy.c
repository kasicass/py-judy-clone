
/* Python wrapper to the Judy package. */
/* This is an autogenerated file.  Modifications will be overwritten. */
#include "pyjudy.h"
#include "pyjudy_common.c"
    /***************** PyJudyLIntInt **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudyLIntInt_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLIntIntIterKey_Type;
extern PyTypeObject PyJudyLIntIntIterValue_Type;
extern PyTypeObject PyJudyLIntIntIterItem_Type;
static PyObject *PyJudyLIntInt_iter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLIntInt_iter(PyObject *container)
{
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iter",
		      0, -1, 0, &PyJudyLIntIntIterKey_Type);
}

static PyObject *
PyJudyLIntInt_iterkeys(PyObject *container)
{
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterkeys",
		      0, -1, 0, &PyJudyLIntIntIterKey_Type);
}

static PyObject *
PyJudyLIntInt_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterkeys_from",
		      index, -1, 0, &PyJudyLIntIntIterKey_Type);
}
static PyObject *
PyJudyLIntInt_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterkeys_to",
		      0, index, 1, &PyJudyLIntIntIterKey_Type);
}

static PyObject *
PyJudyLIntInt_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLIntIntIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLIntInt_itervalues(PyObject *container)
{
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "itervalues",
		      0, -1, 0, &PyJudyLIntIntIterValue_Type);
}
static PyObject *
PyJudyLIntInt_itervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "itervalues_to",
		      index, -1, 0, &PyJudyLIntIntIterValue_Type);

}
static PyObject *
PyJudyLIntInt_itervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "itervalues_to",
		      0, index, 1, &PyJudyLIntIntIterValue_Type);

}
static PyObject *
PyJudyLIntInt_itervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLIntIntIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLIntInt_iteritems(PyObject *container)
{
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iteritems",
		      0, -1, 0, &PyJudyLIntIntIterItem_Type);
}
static PyObject *
PyJudyLIntInt_iteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iteritems_to",
		      index, -1, 0, &PyJudyLIntIntIterItem_Type);

}
static PyObject *
PyJudyLIntInt_iteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iteritems_to",
		      0, index, 1, &PyJudyLIntIntIterItem_Type);

}
static PyObject *
PyJudyLIntInt_iteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLIntIntIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLIntIntIterEmpty_Type;

static PyObject *PyJudyLIntInt_iterempty(PyObject *container)
{
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterempty",
		      0, -1, 0, &PyJudyLIntIntIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterempty_from",
		      index, -1, 0, &PyJudyLIntIntIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterempty_to",
		      0, index, 1, &PyJudyLIntIntIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLIntInt_iter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLIntIntIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudyLIntInt_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLIntIntRIterKey_Type;
extern PyTypeObject PyJudyLIntIntRIterValue_Type;
extern PyTypeObject PyJudyLIntIntRIterItem_Type;
static PyObject *PyJudyLIntInt_riter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLIntInt_riter(PyObject *container)
{
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iter",
		      -1, 0, 0, &PyJudyLIntIntRIterKey_Type);
}

static PyObject *
PyJudyLIntInt_riterkeys(PyObject *container)
{
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterkeys",
		      -1, 0, 0, &PyJudyLIntIntRIterKey_Type);
}

static PyObject *
PyJudyLIntInt_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterkeys_from",
		      index, 0, 0, &PyJudyLIntIntRIterKey_Type);
}
static PyObject *
PyJudyLIntInt_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterkeys_to",
		      -1, index, 1, &PyJudyLIntIntRIterKey_Type);
}

static PyObject *
PyJudyLIntInt_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLIntIntRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLIntInt_ritervalues(PyObject *container)
{
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "itervalues",
		      -1, 0, 0, &PyJudyLIntIntRIterValue_Type);
}
static PyObject *
PyJudyLIntInt_ritervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "itervalues_to",
		      index, 0, 0, &PyJudyLIntIntRIterValue_Type);

}
static PyObject *
PyJudyLIntInt_ritervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "itervalues_to",
		      -1, index, 1, &PyJudyLIntIntRIterValue_Type);

}
static PyObject *
PyJudyLIntInt_ritervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLIntIntRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLIntInt_riteritems(PyObject *container)
{
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iteritems",
		      -1, 0, 0, &PyJudyLIntIntRIterItem_Type);
}
static PyObject *
PyJudyLIntInt_riteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iteritems_to",
		      index, 0, 0, &PyJudyLIntIntRIterItem_Type);

}
static PyObject *
PyJudyLIntInt_riteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iteritems_to",
		      -1, index, 1, &PyJudyLIntIntRIterItem_Type);

}
static PyObject *
PyJudyLIntInt_riteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLIntIntRIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLIntIntRIterEmpty_Type;

static PyObject *PyJudyLIntInt_riterempty(PyObject *container)
{
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterempty",
		      -1, 0, 0, &PyJudyLIntIntRIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterempty_from",
		      index, 0, 0, &PyJudyLIntIntRIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterempty_to",
		      -1, index, 1, &PyJudyLIntIntRIterEmpty_Type);
}
static PyObject *PyJudyLIntInt_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntInt_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLIntInt_riter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLIntIntRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudyLIntInt_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *start_index = index;

  key = end_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudyLIntInt_make_2ple(Word_t index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = PyInt_FromLong(index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = PyInt_FromLong((Word_t)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudyLIntInt_dealloc(PyJudyL* self)
{
  
  JudyLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudyLIntInt_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudyL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudyL *)PyObject_New(PyJudyL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudyLIntInt_MemUsed(PyJudyL *self)
{
  Word_t size;
  size = JudyLMemUsed(self->array);
  return as_unsigned(size);
}

/* Forward declaration */
static int
PyJudyLIntInt_ass_sub(PyJudyL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudyLIntInt_Ins(PyJudyL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudyLIntInt_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudyLIntInt_delitem(PyJudyL *self, PyObject *key)
{
  
    /* Delete */
    long index;
    long success;

    if (!PyInt_CheckExact(key)) {
        PyErr_SetString(PyExc_ValueError, "an integer key is required");
        return -1;
    }
    index = PyInt_AS_LONG(key);


    success = JudyLDel(&(self->array), (Word_t) index, PJE0);
    if (success) {
      return 1;
    }
    return 0;

}

static PyObject *
PyJudyLIntInt_Del(PyJudyL *self, PyObject *key)
{
  int success;
  success = PyJudyLIntInt_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudyLIntInt_Get(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudyLIntInt_get(PyJudyL *self, PyObject *args)
{
  Word_t index;
  PPvoid_t p;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudyLIntInt_Count(PyJudyL *self)
{
  Word_t count;
  count = JudyLCount(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntInt_Count_from(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  count = JudyLCount(self->array, index, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntInt_Count_to(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntInt_Count_range(PyJudyL *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudyLIntInt_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntInt_ByCount(PyJudyL *self, PyObject *key)
{
  PPvoid_t p;
  Word_t index;
  Word_t Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  p = JudyLByCount(self->array, Nth, &index, PJE0);
  if (p == NULL) {
    /* Not found; raise exception */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  /* Return the 2-ple of (index, value) */
  return PyJudyLIntInt_make_2ple(index, p);
}

static PyObject *
PyJudyLIntInt_FreeArray(PyJudyL *self)
{
  
  JudyLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudyLIntInt_First(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  PPvoid_t p;
  PyObject *key=NULL;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  p = JudyLFirst(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntInt_make_2ple(index, p);
}

static PyObject *
PyJudyLIntInt_Next(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLNext(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudyLIntInt_make_2ple(index, p);
}

static PyObject *
PyJudyLIntInt_Last(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  p = JudyLLast(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntInt_make_2ple(index, p);
}

static PyObject *
PyJudyLIntInt_Prev(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLPrev(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntInt_make_2ple(index, p);
}


/* ******** */

static PyObject *
PyJudyLIntInt_FirstEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = JudyLFirstEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntInt_NextEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = JudyLNextEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntInt_LastEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = JudyLLastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntInt_PrevEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = JudyLPrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudyLIntInt_keys(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong(index));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLIntInt_values(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong((Word_t)(*p)));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLIntInt_items(PyJudyL *self)
{
  PyObject *v, *tuple;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudyLIntInt_make_2ple(index, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudyLIntInt_contains(PyJudyL *self, PyObject *key)
{
  Word_t index;
  Pvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);


  p = JudyLGet(self->array, (Word_t) index, PJE0);  
  return (p != NULL);
}

/* Meet the mapping protocol */
static int
PyJudyLIntInt_length(PyJudyL *self)
{
  /* XXX what if count > 2**31? */
  return JudyLCount(self->array, 0, -1, PJE0);
}

static PyObject *
PyJudyLIntInt_subscript(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);

  p = JudyLGet(self->array, (Word_t) index, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static int
PyJudyLIntInt_ass_sub(PyJudyL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudyLIntInt_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
    /* Insert int -> int */
    long index, val;
    PPvoid_t p;

    if (!PyInt_CheckExact(key)) {
        PyErr_SetString(PyExc_ValueError, "an integer key is required");
        return -1;
    }
    index = PyInt_AS_LONG(key);
    if (!PyInt_CheckExact(value)) {
        PyErr_SetString(PyExc_ValueError, "an integer value is required");
        return -1;
    }
    val = PyInt_AS_LONG(value);
       
    p = JudyLIns(&(self->array), (Word_t) index, PJE0);
    if (p == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    *((Word_t *) p) = (Word_t) val;
    return 0;


  }
}


static PyMappingMethods PyJudyLIntInt_as_mapping = {
  (inquiry) PyJudyLIntInt_length,
  (binaryfunc) PyJudyLIntInt_subscript,
  (objobjargproc)PyJudyLIntInt_ass_sub,
};


/* Hack to implement "key in array" */
static PySequenceMethods PyJudyLIntInt_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudyLIntInt_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudyLIntInt_methods[] = {
  {"MemUsed", (PyCFunction) PyJudyLIntInt_MemUsed, METH_NOARGS, 
   "number of bytes of malloced memory used by this array"},
  {"Ins", (PyCFunction) PyJudyLIntInt_Ins, METH_VARARGS, 
   "insert a key and value into the array"},
  {"Del", (PyCFunction) PyJudyLIntInt_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudyLIntInt_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudyLIntInt_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudyLIntInt_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"Count_from", (PyCFunction) PyJudyLIntInt_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudyLIntInt_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudyLIntInt_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudyLIntInt_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudyLIntInt_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudyLIntInt_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudyLIntInt_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input key. "
   "If no input key, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudyLIntInt_Next, METH_O,
   "the next (key, value) tuple where the key is after the input key.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudyLIntInt_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input key. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudyLIntInt_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input key.  If "
   "there are no earlier tuples, raises StopIteration"},
  {"FirstEmpty", (PyCFunction) PyJudyLIntInt_FirstEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "after the input key. If no input, the first empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"NextEmpty", (PyCFunction) PyJudyLIntInt_NextEmpty, METH_O,
   "the location of the next empty key position (as a signed integer) after "
   "the input key. If no empty locations remain, raises StopIteration."},
  {"LastEmpty", (PyCFunction) PyJudyLIntInt_LastEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "before the input key. If no input, the last empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"PrevEmpty", (PyCFunction) PyJudyLIntInt_PrevEmpty, METH_O,
   "the location of the previous empty key position (as a signed integer) before "
   "the input key. If no empty locations remain, raises StopIteration."},

  {"keys", (PyCFunction) PyJudyLIntInt_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudyLIntInt_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudyLIntInt_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudyLIntInt_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudyLIntInt_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudyLIntInt_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudyLIntInt_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input key and "
   "going up to but not including the second"},

  {"itervalues", (PyCFunction) PyJudyLIntInt_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudyLIntInt_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input key"},
  {"itervalues_to", (PyCFunction) PyJudyLIntInt_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input key"},
  {"itervalues_range", (PyCFunction) PyJudyLIntInt_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input key and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudyLIntInt_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudyLIntInt_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input key"},
  {"iteritems_to", (PyCFunction) PyJudyLIntInt_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input key"},
  {"iteritems_range", (PyCFunction) PyJudyLIntInt_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input key and going up to but not including the second "},

  {"riterkeys", (PyCFunction) PyJudyLIntInt_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudyLIntInt_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudyLIntInt_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudyLIntInt_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudyLIntInt_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudyLIntInt_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input key"},
  {"ritervalues_to", (PyCFunction) PyJudyLIntInt_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input key"},
  {"ritervalues_range", (PyCFunction) PyJudyLIntInt_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudyLIntInt_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudyLIntInt_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input key"},
  {"riteritems_to", (PyCFunction) PyJudyLIntInt_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input key"},
  {"riteritems_range", (PyCFunction) PyJudyLIntInt_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input key and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudyLIntInt_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  {"iterempty", (PyCFunction) PyJudyLIntInt_iterempty, METH_NOARGS,
   "iterate through all the possible empty keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudyLIntInt_iterempty_from, METH_O, 
   "iterate through all the possible empty keys (as signed integers) at or "
   "above the given input key"},
  {"iterempty_to", (PyCFunction) PyJudyLIntInt_iterempty_to, METH_O,
   "iterate through all the possible empty keys (as signed integers) up to "
   "but not including the given input key"},
  {"iterempty_range", (PyCFunction) PyJudyLIntInt_iterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudyLIntInt_riterempty, METH_NOARGS,
   "reverse iteration through all the possible empty keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudyLIntInt_riterempty_from, METH_O, 
   "reverse iteration through all the possible empty keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudyLIntInt_riterempty_to, METH_O,
   "reverse iteration through all the possible empty keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudyLIntInt_riterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},
  
  {NULL}
};

/* PyJudyLIntInt */
static PyTypeObject PyJudyLIntIntType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudyLIntInt",             /*tp_name*/
    sizeof(PyJudyL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudyLIntInt_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudyLIntInt_as_sequence,                         /*tp_as_sequence*/
    &PyJudyLIntInt_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudyL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudyLIntInt_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudyLIntInt_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudyLIntInt_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudyLIntInt_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  PyObject *result;  /* reusable result tuple for iteritems */
  Word_t index;
  Word_t stop;
  PyJudyL *container;   /* Set to NULL when iterator is exhausted */
} PyJudyLIntInt_iterobject;

static PyObject *
PyJudyLIntInt_iter_new(PyJudyL *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudyLIntInt_iterobject *it;

  it = PyObject_New(PyJudyLIntInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLIntIntIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudyLIntInt_iter_dealloc(PyJudyLIntInt_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudyLIntIntIter_iternextkey(PyJudyLIntInt_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntIntIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLIntIntIter_iternextvalue(PyJudyLIntInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudyLIntIntIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLIntIntIter_iternextitem(PyJudyLIntInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = PyInt_FromLong(index);
  if (!key)
    return NULL;
  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLIntIntIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemiterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudyLIntInt_riter_new(PyJudyL *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudyLIntInt_iterobject *it;

  it = PyObject_New(PyJudyLIntInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLIntIntRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudyLIntIntRIter_iternextkey(PyJudyLIntInt_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntIntRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLIntIntRIter_iternextvalue(PyJudyLIntInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudyLIntIntRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLIntIntRIter_iternextitem(PyJudyLIntInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = PyInt_FromLong(index);
  if (!key)
    return NULL;

  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLIntIntRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemriterator",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntIntRIter_iternextitem,    /* tp_iternext */
};

/***** Forward iteration over the empty keys *****/

static PyObject *PyJudyLIntInt_iterempty_next(PyJudyLIntInt_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLNextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLFirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntIntIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntInt_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudyLIntInt_riterempty_next(PyJudyLIntInt_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLPrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLLastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntIntRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudyLIntInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntInt_riterempty_next,    /* tp_iternext */
};
/***************** PyJudyLIntObj **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudyLIntObj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLIntObjIterKey_Type;
extern PyTypeObject PyJudyLIntObjIterValue_Type;
extern PyTypeObject PyJudyLIntObjIterItem_Type;
static PyObject *PyJudyLIntObj_iter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLIntObj_iter(PyObject *container)
{
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iter",
		      0, -1, 0, &PyJudyLIntObjIterKey_Type);
}

static PyObject *
PyJudyLIntObj_iterkeys(PyObject *container)
{
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterkeys",
		      0, -1, 0, &PyJudyLIntObjIterKey_Type);
}

static PyObject *
PyJudyLIntObj_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterkeys_from",
		      index, -1, 0, &PyJudyLIntObjIterKey_Type);
}
static PyObject *
PyJudyLIntObj_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterkeys_to",
		      0, index, 1, &PyJudyLIntObjIterKey_Type);
}

static PyObject *
PyJudyLIntObj_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLIntObjIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLIntObj_itervalues(PyObject *container)
{
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "itervalues",
		      0, -1, 0, &PyJudyLIntObjIterValue_Type);
}
static PyObject *
PyJudyLIntObj_itervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "itervalues_to",
		      index, -1, 0, &PyJudyLIntObjIterValue_Type);

}
static PyObject *
PyJudyLIntObj_itervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "itervalues_to",
		      0, index, 1, &PyJudyLIntObjIterValue_Type);

}
static PyObject *
PyJudyLIntObj_itervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLIntObjIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLIntObj_iteritems(PyObject *container)
{
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iteritems",
		      0, -1, 0, &PyJudyLIntObjIterItem_Type);
}
static PyObject *
PyJudyLIntObj_iteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iteritems_to",
		      index, -1, 0, &PyJudyLIntObjIterItem_Type);

}
static PyObject *
PyJudyLIntObj_iteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iteritems_to",
		      0, index, 1, &PyJudyLIntObjIterItem_Type);

}
static PyObject *
PyJudyLIntObj_iteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLIntObjIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLIntObjIterEmpty_Type;

static PyObject *PyJudyLIntObj_iterempty(PyObject *container)
{
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterempty",
		      0, -1, 0, &PyJudyLIntObjIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterempty_from",
		      index, -1, 0, &PyJudyLIntObjIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterempty_to",
		      0, index, 1, &PyJudyLIntObjIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLIntObj_iter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLIntObjIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudyLIntObj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLIntObjRIterKey_Type;
extern PyTypeObject PyJudyLIntObjRIterValue_Type;
extern PyTypeObject PyJudyLIntObjRIterItem_Type;
static PyObject *PyJudyLIntObj_riter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLIntObj_riter(PyObject *container)
{
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iter",
		      -1, 0, 0, &PyJudyLIntObjRIterKey_Type);
}

static PyObject *
PyJudyLIntObj_riterkeys(PyObject *container)
{
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterkeys",
		      -1, 0, 0, &PyJudyLIntObjRIterKey_Type);
}

static PyObject *
PyJudyLIntObj_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterkeys_from",
		      index, 0, 0, &PyJudyLIntObjRIterKey_Type);
}
static PyObject *
PyJudyLIntObj_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterkeys_to",
		      -1, index, 1, &PyJudyLIntObjRIterKey_Type);
}

static PyObject *
PyJudyLIntObj_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLIntObjRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLIntObj_ritervalues(PyObject *container)
{
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "itervalues",
		      -1, 0, 0, &PyJudyLIntObjRIterValue_Type);
}
static PyObject *
PyJudyLIntObj_ritervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "itervalues_to",
		      index, 0, 0, &PyJudyLIntObjRIterValue_Type);

}
static PyObject *
PyJudyLIntObj_ritervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "itervalues_to",
		      -1, index, 1, &PyJudyLIntObjRIterValue_Type);

}
static PyObject *
PyJudyLIntObj_ritervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLIntObjRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLIntObj_riteritems(PyObject *container)
{
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iteritems",
		      -1, 0, 0, &PyJudyLIntObjRIterItem_Type);
}
static PyObject *
PyJudyLIntObj_riteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iteritems_to",
		      index, 0, 0, &PyJudyLIntObjRIterItem_Type);

}
static PyObject *
PyJudyLIntObj_riteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iteritems_to",
		      -1, index, 1, &PyJudyLIntObjRIterItem_Type);

}
static PyObject *
PyJudyLIntObj_riteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLIntObjRIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLIntObjRIterEmpty_Type;

static PyObject *PyJudyLIntObj_riterempty(PyObject *container)
{
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterempty",
		      -1, 0, 0, &PyJudyLIntObjRIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterempty_from",
		      index, 0, 0, &PyJudyLIntObjRIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterempty_to",
		      -1, index, 1, &PyJudyLIntObjRIterEmpty_Type);
}
static PyObject *PyJudyLIntObj_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLIntObj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLIntObj_riter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLIntObjRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudyLIntObj_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *start_index = index;

  key = end_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudyLIntObj_make_2ple(Word_t index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = PyInt_FromLong(index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudyLIntObj_dealloc(PyJudyL* self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = *((PyObject **)p);
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudyLIntObj_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudyL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudyL *)PyObject_New(PyJudyL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudyLIntObj_MemUsed(PyJudyL *self)
{
  Word_t size;
  size = JudyLMemUsed(self->array);
  return as_unsigned(size);
}

/* Forward declaration */
static int
PyJudyLIntObj_ass_sub(PyJudyL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudyLIntObj_Ins(PyJudyL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudyLIntObj_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudyLIntObj_delitem(PyJudyL *self, PyObject *key)
{
  
    /* Delete int -> object array */
    long index;
    long success;
    PPvoid_t p;
    PyObject *obj;

    if (!PyInt_CheckExact(key)) {
        PyErr_SetString(PyExc_ValueError, "an integer key is required");
        return -1;
    }
    index = PyInt_AS_LONG(key);

    /* does something already exist? */
    p = JudyLGet(self->array, (Word_t) index, PJE0);
    if (p == NULL) {
      return 0;  /* Let the caller set the exception if appropriate */
    }
    /* decref and remove */
    obj = *((PyObject **)p);
    Py_DECREF(obj);
    
    success = JudyLDel(&(self->array), (Word_t) index, PJE0);
    if (!success) {
      /* is there any other way for delete to fail after a get? */
      PyErr_NoMemory();
      return -1;
    }
    return 1;

}

static PyObject *
PyJudyLIntObj_Del(PyJudyL *self, PyObject *key)
{
  int success;
  success = PyJudyLIntObj_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudyLIntObj_Get(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudyLIntObj_get(PyJudyL *self, PyObject *args)
{
  Word_t index;
  PPvoid_t p;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudyLIntObj_Count(PyJudyL *self)
{
  Word_t count;
  count = JudyLCount(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntObj_Count_from(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  count = JudyLCount(self->array, index, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntObj_Count_to(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntObj_Count_range(PyJudyL *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudyLIntObj_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLIntObj_ByCount(PyJudyL *self, PyObject *key)
{
  PPvoid_t p;
  Word_t index;
  Word_t Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  p = JudyLByCount(self->array, Nth, &index, PJE0);
  if (p == NULL) {
    /* Not found; raise exception */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  /* Return the 2-ple of (index, value) */
  return PyJudyLIntObj_make_2ple(index, p);
}

static PyObject *
PyJudyLIntObj_FreeArray(PyJudyL *self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = *((PyObject **)p);
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudyLIntObj_First(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  PPvoid_t p;
  PyObject *key=NULL;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  p = JudyLFirst(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntObj_make_2ple(index, p);
}

static PyObject *
PyJudyLIntObj_Next(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLNext(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudyLIntObj_make_2ple(index, p);
}

static PyObject *
PyJudyLIntObj_Last(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  p = JudyLLast(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntObj_make_2ple(index, p);
}

static PyObject *
PyJudyLIntObj_Prev(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  p = JudyLPrev(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLIntObj_make_2ple(index, p);
}


/* ******** */

static PyObject *
PyJudyLIntObj_FirstEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = JudyLFirstEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntObj_NextEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = JudyLNextEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntObj_LastEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = JudyLLastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLIntObj_PrevEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = JudyLPrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudyLIntObj_keys(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong(index));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLIntObj_values(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p)));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLIntObj_items(PyJudyL *self)
{
  PyObject *v, *tuple;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudyLIntObj_make_2ple(index, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudyLIntObj_contains(PyJudyL *self, PyObject *key)
{
  Word_t index;
  Pvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);


  p = JudyLGet(self->array, (Word_t) index, PJE0);  
  return (p != NULL);
}

/* Meet the mapping protocol */
static int
PyJudyLIntObj_length(PyJudyL *self)
{
  /* XXX what if count > 2**31? */
  return JudyLCount(self->array, 0, -1, PJE0);
}

static PyObject *
PyJudyLIntObj_subscript(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);

  p = JudyLGet(self->array, (Word_t) index, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static int
PyJudyLIntObj_ass_sub(PyJudyL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudyLIntObj_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
    /* Insert int -> obj */
    long index;
    PPvoid_t p;

    if (!PyInt_CheckExact(key)) {
        PyErr_SetString(PyExc_ValueError, "an integer key is required");
        return -1;
    }
    index = PyInt_AS_LONG(key);
        
    /* Does it already exist? */
    p = JudyLGet(self->array, (Word_t) index, PJE0);
    if (p != NULL) {
      /* Replace the existing value with the new one */
      Py_INCREF(value);
      Py_DECREF(*((PyObject **)p));
      *((PyObject **)p) = value;
      return 0;
    }
    /* Does not exist so add it */
    p = JudyLIns(&(self->array), (Word_t) index, PJE0);
    if (p == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    Py_INCREF(value);
    *((PyObject **)p) = value;
    return 0;


  }
}


static PyMappingMethods PyJudyLIntObj_as_mapping = {
  (inquiry) PyJudyLIntObj_length,
  (binaryfunc) PyJudyLIntObj_subscript,
  (objobjargproc)PyJudyLIntObj_ass_sub,
};


/* Hack to implement "key in array" */
static PySequenceMethods PyJudyLIntObj_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudyLIntObj_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudyLIntObj_methods[] = {
  {"MemUsed", (PyCFunction) PyJudyLIntObj_MemUsed, METH_NOARGS, 
   "number of bytes of malloced memory used by this array"},
  {"Ins", (PyCFunction) PyJudyLIntObj_Ins, METH_VARARGS, 
   "insert a key and value into the array"},
  {"Del", (PyCFunction) PyJudyLIntObj_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudyLIntObj_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudyLIntObj_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudyLIntObj_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"Count_from", (PyCFunction) PyJudyLIntObj_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudyLIntObj_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudyLIntObj_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudyLIntObj_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudyLIntObj_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudyLIntObj_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudyLIntObj_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input key. "
   "If no input key, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudyLIntObj_Next, METH_O,
   "the next (key, value) tuple where the key is after the input key.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudyLIntObj_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input key. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudyLIntObj_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input key.  If "
   "there are no earlier tuples, raises StopIteration"},
  {"FirstEmpty", (PyCFunction) PyJudyLIntObj_FirstEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "after the input key. If no input, the first empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"NextEmpty", (PyCFunction) PyJudyLIntObj_NextEmpty, METH_O,
   "the location of the next empty key position (as a signed integer) after "
   "the input key. If no empty locations remain, raises StopIteration."},
  {"LastEmpty", (PyCFunction) PyJudyLIntObj_LastEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "before the input key. If no input, the last empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"PrevEmpty", (PyCFunction) PyJudyLIntObj_PrevEmpty, METH_O,
   "the location of the previous empty key position (as a signed integer) before "
   "the input key. If no empty locations remain, raises StopIteration."},

  {"keys", (PyCFunction) PyJudyLIntObj_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudyLIntObj_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudyLIntObj_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudyLIntObj_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudyLIntObj_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudyLIntObj_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudyLIntObj_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input key and "
   "going up to but not including the second"},

  {"itervalues", (PyCFunction) PyJudyLIntObj_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudyLIntObj_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input key"},
  {"itervalues_to", (PyCFunction) PyJudyLIntObj_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input key"},
  {"itervalues_range", (PyCFunction) PyJudyLIntObj_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input key and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudyLIntObj_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudyLIntObj_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input key"},
  {"iteritems_to", (PyCFunction) PyJudyLIntObj_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input key"},
  {"iteritems_range", (PyCFunction) PyJudyLIntObj_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input key and going up to but not including the second "},

  {"riterkeys", (PyCFunction) PyJudyLIntObj_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudyLIntObj_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudyLIntObj_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudyLIntObj_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudyLIntObj_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudyLIntObj_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input key"},
  {"ritervalues_to", (PyCFunction) PyJudyLIntObj_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input key"},
  {"ritervalues_range", (PyCFunction) PyJudyLIntObj_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudyLIntObj_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudyLIntObj_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input key"},
  {"riteritems_to", (PyCFunction) PyJudyLIntObj_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input key"},
  {"riteritems_range", (PyCFunction) PyJudyLIntObj_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input key and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudyLIntObj_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  {"iterempty", (PyCFunction) PyJudyLIntObj_iterempty, METH_NOARGS,
   "iterate through all the possible empty keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudyLIntObj_iterempty_from, METH_O, 
   "iterate through all the possible empty keys (as signed integers) at or "
   "above the given input key"},
  {"iterempty_to", (PyCFunction) PyJudyLIntObj_iterempty_to, METH_O,
   "iterate through all the possible empty keys (as signed integers) up to "
   "but not including the given input key"},
  {"iterempty_range", (PyCFunction) PyJudyLIntObj_iterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudyLIntObj_riterempty, METH_NOARGS,
   "reverse iteration through all the possible empty keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudyLIntObj_riterempty_from, METH_O, 
   "reverse iteration through all the possible empty keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudyLIntObj_riterempty_to, METH_O,
   "reverse iteration through all the possible empty keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudyLIntObj_riterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},
  
  {NULL}
};

/* PyJudyLIntObj */
static PyTypeObject PyJudyLIntObjType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudyLIntObj",             /*tp_name*/
    sizeof(PyJudyL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudyLIntObj_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudyLIntObj_as_sequence,                         /*tp_as_sequence*/
    &PyJudyLIntObj_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudyL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudyLIntObj_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudyLIntObj_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudyLIntObj_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudyLIntObj_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  PyObject *result;  /* reusable result tuple for iteritems */
  Word_t index;
  Word_t stop;
  PyJudyL *container;   /* Set to NULL when iterator is exhausted */
} PyJudyLIntObj_iterobject;

static PyObject *
PyJudyLIntObj_iter_new(PyJudyL *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudyLIntObj_iterobject *it;

  it = PyObject_New(PyJudyLIntObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLIntObjIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudyLIntObj_iter_dealloc(PyJudyLIntObj_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudyLIntObjIter_iternextkey(PyJudyLIntObj_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntObjIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLIntObjIter_iternextvalue(PyJudyLIntObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudyLIntObjIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLIntObjIter_iternextitem(PyJudyLIntObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = PyInt_FromLong(index);
  if (!key)
    return NULL;
  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLIntObjIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemiterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudyLIntObj_riter_new(PyJudyL *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudyLIntObj_iterobject *it;

  it = PyObject_New(PyJudyLIntObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLIntObjRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudyLIntObjRIter_iternextkey(PyJudyLIntObj_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntObjRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLIntObjRIter_iternextvalue(PyJudyLIntObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudyLIntObjRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLIntObjRIter_iternextitem(PyJudyLIntObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = PyInt_FromLong(index);
  if (!key)
    return NULL;

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLIntObjRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemriterator",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObjRIter_iternextitem,    /* tp_iternext */
};

/***** Forward iteration over the empty keys *****/

static PyObject *PyJudyLIntObj_iterempty_next(PyJudyLIntObj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLNextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLFirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntObjIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObj_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudyLIntObj_riterempty_next(PyJudyLIntObj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLPrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLLastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLIntObjRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudyLIntObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLIntObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLIntObj_riterempty_next,    /* tp_iternext */
};
/***************** PyJudyLObjObj **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudyLObjObj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLObjObjIterKey_Type;
extern PyTypeObject PyJudyLObjObjIterValue_Type;
extern PyTypeObject PyJudyLObjObjIterItem_Type;
static PyObject *PyJudyLObjObj_iter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLObjObj_iter(PyObject *container)
{
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iter",
		      0, -1, 0, &PyJudyLObjObjIterKey_Type);
}

static PyObject *
PyJudyLObjObj_iterkeys(PyObject *container)
{
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterkeys",
		      0, -1, 0, &PyJudyLObjObjIterKey_Type);
}

static PyObject *
PyJudyLObjObj_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterkeys_from",
		      index, -1, 0, &PyJudyLObjObjIterKey_Type);
}
static PyObject *
PyJudyLObjObj_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterkeys_to",
		      0, index, 1, &PyJudyLObjObjIterKey_Type);
}

static PyObject *
PyJudyLObjObj_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLObjObjIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLObjObj_itervalues(PyObject *container)
{
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "itervalues",
		      0, -1, 0, &PyJudyLObjObjIterValue_Type);
}
static PyObject *
PyJudyLObjObj_itervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "itervalues_to",
		      index, -1, 0, &PyJudyLObjObjIterValue_Type);

}
static PyObject *
PyJudyLObjObj_itervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "itervalues_to",
		      0, index, 1, &PyJudyLObjObjIterValue_Type);

}
static PyObject *
PyJudyLObjObj_itervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLObjObjIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLObjObj_iteritems(PyObject *container)
{
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iteritems",
		      0, -1, 0, &PyJudyLObjObjIterItem_Type);
}
static PyObject *
PyJudyLObjObj_iteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iteritems_to",
		      index, -1, 0, &PyJudyLObjObjIterItem_Type);

}
static PyObject *
PyJudyLObjObj_iteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iteritems_to",
		      0, index, 1, &PyJudyLObjObjIterItem_Type);

}
static PyObject *
PyJudyLObjObj_iteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLObjObjIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLObjObjIterEmpty_Type;

static PyObject *PyJudyLObjObj_iterempty(PyObject *container)
{
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterempty",
		      0, -1, 0, &PyJudyLObjObjIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterempty_from",
		      index, -1, 0, &PyJudyLObjObjIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterempty_to",
		      0, index, 1, &PyJudyLObjObjIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLObjObj_iter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLObjObjIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudyLObjObj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLObjObjRIterKey_Type;
extern PyTypeObject PyJudyLObjObjRIterValue_Type;
extern PyTypeObject PyJudyLObjObjRIterItem_Type;
static PyObject *PyJudyLObjObj_riter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLObjObj_riter(PyObject *container)
{
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iter",
		      -1, 0, 0, &PyJudyLObjObjRIterKey_Type);
}

static PyObject *
PyJudyLObjObj_riterkeys(PyObject *container)
{
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterkeys",
		      -1, 0, 0, &PyJudyLObjObjRIterKey_Type);
}

static PyObject *
PyJudyLObjObj_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterkeys_from",
		      index, 0, 0, &PyJudyLObjObjRIterKey_Type);
}
static PyObject *
PyJudyLObjObj_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterkeys_to",
		      -1, index, 1, &PyJudyLObjObjRIterKey_Type);
}

static PyObject *
PyJudyLObjObj_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLObjObjRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLObjObj_ritervalues(PyObject *container)
{
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "itervalues",
		      -1, 0, 0, &PyJudyLObjObjRIterValue_Type);
}
static PyObject *
PyJudyLObjObj_ritervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "itervalues_to",
		      index, 0, 0, &PyJudyLObjObjRIterValue_Type);

}
static PyObject *
PyJudyLObjObj_ritervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "itervalues_to",
		      -1, index, 1, &PyJudyLObjObjRIterValue_Type);

}
static PyObject *
PyJudyLObjObj_ritervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLObjObjRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLObjObj_riteritems(PyObject *container)
{
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iteritems",
		      -1, 0, 0, &PyJudyLObjObjRIterItem_Type);
}
static PyObject *
PyJudyLObjObj_riteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iteritems_to",
		      index, 0, 0, &PyJudyLObjObjRIterItem_Type);

}
static PyObject *
PyJudyLObjObj_riteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iteritems_to",
		      -1, index, 1, &PyJudyLObjObjRIterItem_Type);

}
static PyObject *
PyJudyLObjObj_riteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLObjObjRIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLObjObjRIterEmpty_Type;

static PyObject *PyJudyLObjObj_riterempty(PyObject *container)
{
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterempty",
		      -1, 0, 0, &PyJudyLObjObjRIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterempty_from",
		      index, 0, 0, &PyJudyLObjObjRIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterempty_to",
		      -1, index, 1, &PyJudyLObjObjRIterEmpty_Type);
}
static PyObject *PyJudyLObjObj_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjObj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLObjObj_riter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLObjObjRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudyLObjObj_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  index = (Word_t) key;;
  *start_index = index;

  key = end_key;
  index = (Word_t) key;;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudyLObjObj_make_2ple(Word_t index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudyLObjObj_dealloc(PyJudyL* self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      obj = *((PyObject **)p);
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudyLObjObj_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudyL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudyL *)PyObject_New(PyJudyL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudyLObjObj_MemUsed(PyJudyL *self)
{
  Word_t size;
  size = JudyLMemUsed(self->array);
  return as_unsigned(size);
}

/* Forward declaration */
static int
PyJudyLObjObj_ass_sub(PyJudyL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudyLObjObj_Ins(PyJudyL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudyLObjObj_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudyLObjObj_delitem(PyJudyL *self, PyObject *key)
{
  
    /* Delete object -> object array */
    long success;
    PPvoid_t p;
    PyObject *obj;

    /* does something already exist? */
    p = JudyLGet(self->array, (Word_t) key, PJE0);
    if (p == NULL) {
      return 0;   /* Let the caller set the exception if appropriate */
    }
    /* decref and remove */
    Py_DECREF(key);
    obj = *((PyObject **)p);
    Py_DECREF(obj);
    
    success = JudyLDel(&(self->array), (Word_t) key, PJE0);
    if (!success) {
      /* is there any other way for delete to fail after a get? */
      PyErr_NoMemory();
      return -1;
    }
    return 1;

}

static PyObject *
PyJudyLObjObj_Del(PyJudyL *self, PyObject *key)
{
  int success;
  success = PyJudyLObjObj_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudyLObjObj_Get(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudyLObjObj_get(PyJudyL *self, PyObject *args)
{
  Word_t index;
  PPvoid_t p;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  index = (Word_t) key;;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudyLObjObj_Count(PyJudyL *self)
{
  Word_t count;
  count = JudyLCount(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjObj_Count_from(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  count = JudyLCount(self->array, index, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjObj_Count_to(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjObj_Count_range(PyJudyL *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudyLObjObj_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjObj_ByCount(PyJudyL *self, PyObject *key)
{
  PPvoid_t p;
  Word_t index;
  Word_t Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  p = JudyLByCount(self->array, Nth, &index, PJE0);
  if (p == NULL) {
    /* Not found; raise exception */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  /* Return the 2-ple of (index, value) */
  return PyJudyLObjObj_make_2ple(index, p);
}

static PyObject *
PyJudyLObjObj_FreeArray(PyJudyL *self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      obj = *((PyObject **)p);
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudyLObjObj_First(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  PPvoid_t p;
  PyObject *key=NULL;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  p = JudyLFirst(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjObj_make_2ple(index, p);
}

static PyObject *
PyJudyLObjObj_Next(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLNext(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudyLObjObj_make_2ple(index, p);
}

static PyObject *
PyJudyLObjObj_Last(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  p = JudyLLast(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjObj_make_2ple(index, p);
}

static PyObject *
PyJudyLObjObj_Prev(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLPrev(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjObj_make_2ple(index, p);
}


/* ******** */

static PyObject *
PyJudyLObjObj_FirstEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = JudyLFirstEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjObj_NextEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = JudyLNextEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjObj_LastEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = JudyLLastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjObj_PrevEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = JudyLPrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudyLObjObj_keys(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)index), (PyObject *)index));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLObjObj_values(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p)));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLObjObj_items(PyJudyL *self)
{
  PyObject *v, *tuple;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudyLObjObj_make_2ple(index, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudyLObjObj_contains(PyJudyL *self, PyObject *key)
{
  Word_t index;
  Pvoid_t p;

  index = (Word_t) key;

  p = JudyLGet(self->array, (Word_t) index, PJE0);  
  return (p != NULL);
}

/* Meet the mapping protocol */
static int
PyJudyLObjObj_length(PyJudyL *self)
{
  /* XXX what if count > 2**31? */
  return JudyLCount(self->array, 0, -1, PJE0);
}

static PyObject *
PyJudyLObjObj_subscript(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;
  p = JudyLGet(self->array, (Word_t) index, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static int
PyJudyLObjObj_ass_sub(PyJudyL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudyLObjObj_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
    /* Insert obj -> obj */
    PPvoid_t p;
    
    /* See if the entry already exists */
    p = JudyLGet(self->array, (Word_t) key, PJE0);
    if (p != NULL) {
        /* no need to touch the refcount on the key */
        Py_INCREF(value);
        Py_DECREF(*((PyObject **)p));
        *((PyObject **)p) = value;
        return 0;
    }
    /* Does not exist so add it */
    p = JudyLIns(&(self->array), (Word_t) key, PJE0);
    if (p == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    Py_INCREF(key);
    Py_INCREF(value);
    *((PyObject **)p) = value;
    return 0;


  }
}


static PyMappingMethods PyJudyLObjObj_as_mapping = {
  (inquiry) PyJudyLObjObj_length,
  (binaryfunc) PyJudyLObjObj_subscript,
  (objobjargproc)PyJudyLObjObj_ass_sub,
};


/* Hack to implement "key in array" */
static PySequenceMethods PyJudyLObjObj_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudyLObjObj_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudyLObjObj_methods[] = {
  {"MemUsed", (PyCFunction) PyJudyLObjObj_MemUsed, METH_NOARGS, 
   "number of bytes of malloced memory used by this array"},
  {"Ins", (PyCFunction) PyJudyLObjObj_Ins, METH_VARARGS, 
   "insert a key and value into the array"},
  {"Del", (PyCFunction) PyJudyLObjObj_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudyLObjObj_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudyLObjObj_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudyLObjObj_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"Count_from", (PyCFunction) PyJudyLObjObj_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudyLObjObj_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudyLObjObj_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudyLObjObj_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudyLObjObj_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudyLObjObj_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudyLObjObj_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input key. "
   "If no input key, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudyLObjObj_Next, METH_O,
   "the next (key, value) tuple where the key is after the input key.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudyLObjObj_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input key. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudyLObjObj_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input key.  If "
   "there are no earlier tuples, raises StopIteration"},
  {"FirstEmpty", (PyCFunction) PyJudyLObjObj_FirstEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "after the input key. If no input, the first empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"NextEmpty", (PyCFunction) PyJudyLObjObj_NextEmpty, METH_O,
   "the location of the next empty key position (as a signed integer) after "
   "the input key. If no empty locations remain, raises StopIteration."},
  {"LastEmpty", (PyCFunction) PyJudyLObjObj_LastEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "before the input key. If no input, the last empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"PrevEmpty", (PyCFunction) PyJudyLObjObj_PrevEmpty, METH_O,
   "the location of the previous empty key position (as a signed integer) before "
   "the input key. If no empty locations remain, raises StopIteration."},

  {"keys", (PyCFunction) PyJudyLObjObj_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudyLObjObj_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudyLObjObj_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudyLObjObj_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudyLObjObj_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudyLObjObj_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudyLObjObj_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input key and "
   "going up to but not including the second"},

  {"itervalues", (PyCFunction) PyJudyLObjObj_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudyLObjObj_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input key"},
  {"itervalues_to", (PyCFunction) PyJudyLObjObj_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input key"},
  {"itervalues_range", (PyCFunction) PyJudyLObjObj_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input key and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudyLObjObj_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudyLObjObj_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input key"},
  {"iteritems_to", (PyCFunction) PyJudyLObjObj_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input key"},
  {"iteritems_range", (PyCFunction) PyJudyLObjObj_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input key and going up to but not including the second "},

  {"riterkeys", (PyCFunction) PyJudyLObjObj_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudyLObjObj_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudyLObjObj_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudyLObjObj_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudyLObjObj_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudyLObjObj_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input key"},
  {"ritervalues_to", (PyCFunction) PyJudyLObjObj_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input key"},
  {"ritervalues_range", (PyCFunction) PyJudyLObjObj_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudyLObjObj_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudyLObjObj_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input key"},
  {"riteritems_to", (PyCFunction) PyJudyLObjObj_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input key"},
  {"riteritems_range", (PyCFunction) PyJudyLObjObj_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input key and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudyLObjObj_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  {"iterempty", (PyCFunction) PyJudyLObjObj_iterempty, METH_NOARGS,
   "iterate through all the possible empty keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudyLObjObj_iterempty_from, METH_O, 
   "iterate through all the possible empty keys (as signed integers) at or "
   "above the given input key"},
  {"iterempty_to", (PyCFunction) PyJudyLObjObj_iterempty_to, METH_O,
   "iterate through all the possible empty keys (as signed integers) up to "
   "but not including the given input key"},
  {"iterempty_range", (PyCFunction) PyJudyLObjObj_iterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudyLObjObj_riterempty, METH_NOARGS,
   "reverse iteration through all the possible empty keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudyLObjObj_riterempty_from, METH_O, 
   "reverse iteration through all the possible empty keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudyLObjObj_riterempty_to, METH_O,
   "reverse iteration through all the possible empty keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudyLObjObj_riterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},
  
  {NULL}
};

/* PyJudyLObjObj */
static PyTypeObject PyJudyLObjObjType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudyLObjObj",             /*tp_name*/
    sizeof(PyJudyL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudyLObjObj_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudyLObjObj_as_sequence,                         /*tp_as_sequence*/
    &PyJudyLObjObj_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudyL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudyLObjObj_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudyLObjObj_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudyLObjObj_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudyLObjObj_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  PyObject *result;  /* reusable result tuple for iteritems */
  Word_t index;
  Word_t stop;
  PyJudyL *container;   /* Set to NULL when iterator is exhausted */
} PyJudyLObjObj_iterobject;

static PyObject *
PyJudyLObjObj_iter_new(PyJudyL *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudyLObjObj_iterobject *it;

  it = PyObject_New(PyJudyLObjObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLObjObjIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudyLObjObj_iter_dealloc(PyJudyLObjObj_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudyLObjObjIter_iternextkey(PyJudyLObjObj_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudyLObjObjIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLObjObjIter_iternextvalue(PyJudyLObjObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudyLObjObjIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLObjObjIter_iternextitem(PyJudyLObjObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (!key)
    return NULL;
  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLObjObjIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemiterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudyLObjObj_riter_new(PyJudyL *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudyLObjObj_iterobject *it;

  it = PyObject_New(PyJudyLObjObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLObjObjRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudyLObjObjRIter_iternextkey(PyJudyLObjObj_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudyLObjObjRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLObjObjRIter_iternextvalue(PyJudyLObjObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudyLObjObjRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLObjObjRIter_iternextitem(PyJudyLObjObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (!key)
    return NULL;

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLObjObjRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemriterator",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObjRIter_iternextitem,    /* tp_iternext */
};

/***** Forward iteration over the empty keys *****/

static PyObject *PyJudyLObjObj_iterempty_next(PyJudyLObjObj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLNextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLFirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLObjObjIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObj_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudyLObjObj_riterempty_next(PyJudyLObjObj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLPrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLLastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLObjObjRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudyLObjObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjObj_riterempty_next,    /* tp_iternext */
};
/***************** PyJudyLObjInt **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudyLObjInt_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLObjIntIterKey_Type;
extern PyTypeObject PyJudyLObjIntIterValue_Type;
extern PyTypeObject PyJudyLObjIntIterItem_Type;
static PyObject *PyJudyLObjInt_iter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLObjInt_iter(PyObject *container)
{
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iter",
		      0, -1, 0, &PyJudyLObjIntIterKey_Type);
}

static PyObject *
PyJudyLObjInt_iterkeys(PyObject *container)
{
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterkeys",
		      0, -1, 0, &PyJudyLObjIntIterKey_Type);
}

static PyObject *
PyJudyLObjInt_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterkeys_from",
		      index, -1, 0, &PyJudyLObjIntIterKey_Type);
}
static PyObject *
PyJudyLObjInt_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterkeys_to",
		      0, index, 1, &PyJudyLObjIntIterKey_Type);
}

static PyObject *
PyJudyLObjInt_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLObjIntIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLObjInt_itervalues(PyObject *container)
{
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "itervalues",
		      0, -1, 0, &PyJudyLObjIntIterValue_Type);
}
static PyObject *
PyJudyLObjInt_itervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "itervalues_to",
		      index, -1, 0, &PyJudyLObjIntIterValue_Type);

}
static PyObject *
PyJudyLObjInt_itervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "itervalues_to",
		      0, index, 1, &PyJudyLObjIntIterValue_Type);

}
static PyObject *
PyJudyLObjInt_itervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLObjIntIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLObjInt_iteritems(PyObject *container)
{
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iteritems",
		      0, -1, 0, &PyJudyLObjIntIterItem_Type);
}
static PyObject *
PyJudyLObjInt_iteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iteritems_to",
		      index, -1, 0, &PyJudyLObjIntIterItem_Type);

}
static PyObject *
PyJudyLObjInt_iteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iteritems_to",
		      0, index, 1, &PyJudyLObjIntIterItem_Type);

}
static PyObject *
PyJudyLObjInt_iteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLObjIntIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLObjIntIterEmpty_Type;

static PyObject *PyJudyLObjInt_iterempty(PyObject *container)
{
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterempty",
		      0, -1, 0, &PyJudyLObjIntIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterempty_from",
		      index, -1, 0, &PyJudyLObjIntIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterempty_to",
		      0, index, 1, &PyJudyLObjIntIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLObjInt_iter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLObjIntIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudyLObjInt_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudyLObjIntRIterKey_Type;
extern PyTypeObject PyJudyLObjIntRIterValue_Type;
extern PyTypeObject PyJudyLObjIntRIterItem_Type;
static PyObject *PyJudyLObjInt_riter_new(PyJudyL *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudyLObjInt_riter(PyObject *container)
{
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iter",
		      -1, 0, 0, &PyJudyLObjIntRIterKey_Type);
}

static PyObject *
PyJudyLObjInt_riterkeys(PyObject *container)
{
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterkeys",
		      -1, 0, 0, &PyJudyLObjIntRIterKey_Type);
}

static PyObject *
PyJudyLObjInt_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterkeys_from",
		      index, 0, 0, &PyJudyLObjIntRIterKey_Type);
}
static PyObject *
PyJudyLObjInt_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterkeys_to",
		      -1, index, 1, &PyJudyLObjIntRIterKey_Type);
}

static PyObject *
PyJudyLObjInt_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterkey_range",
		      start, end, 1, &PyJudyLObjIntRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudyLObjInt_ritervalues(PyObject *container)
{
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "itervalues",
		      -1, 0, 0, &PyJudyLObjIntRIterValue_Type);
}
static PyObject *
PyJudyLObjInt_ritervalues_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "itervalues_to",
		      index, 0, 0, &PyJudyLObjIntRIterValue_Type);

}
static PyObject *
PyJudyLObjInt_ritervalues_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "itervalues_to",
		      -1, index, 1, &PyJudyLObjIntRIterValue_Type);

}
static PyObject *
PyJudyLObjInt_ritervalues_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "itervalues_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "itervalues_range",
		      start, end, 1, &PyJudyLObjIntRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudyLObjInt_riteritems(PyObject *container)
{
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iteritems",
		      -1, 0, 0, &PyJudyLObjIntRIterItem_Type);
}
static PyObject *
PyJudyLObjInt_riteritems_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iteritems_to",
		      index, 0, 0, &PyJudyLObjIntRIterItem_Type);

}
static PyObject *
PyJudyLObjInt_riteritems_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iteritems_to",
		      -1, index, 1, &PyJudyLObjIntRIterItem_Type);

}
static PyObject *
PyJudyLObjInt_riteritems_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iteritems_range", &start, &end))
    return NULL;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iteritems_range",
		      start, end, 1, &PyJudyLObjIntRIterItem_Type);

}

/* Forward empty iteration */
extern PyTypeObject PyJudyLObjIntRIterEmpty_Type;

static PyObject *PyJudyLObjInt_riterempty(PyObject *container)
{
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterempty",
		      -1, 0, 0, &PyJudyLObjIntRIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterempty_from",
		      index, 0, 0, &PyJudyLObjIntRIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterempty_to",
		      -1, index, 1, &PyJudyLObjIntRIterEmpty_Type);
}
static PyObject *PyJudyLObjInt_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudyLObjInt_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudyLObjInt_riter_new((PyJudyL *)container, "iterempty_range",
		      start, end, 1, &PyJudyLObjIntRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudyLObjInt_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  index = (Word_t) key;;
  *start_index = index;

  key = end_key;
  index = (Word_t) key;;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudyLObjInt_make_2ple(Word_t index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = PyInt_FromLong((Word_t)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudyLObjInt_dealloc(PyJudyL* self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudyLObjInt_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudyL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudyL *)PyObject_New(PyJudyL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudyLObjInt_MemUsed(PyJudyL *self)
{
  Word_t size;
  size = JudyLMemUsed(self->array);
  return as_unsigned(size);
}

/* Forward declaration */
static int
PyJudyLObjInt_ass_sub(PyJudyL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudyLObjInt_Ins(PyJudyL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudyLObjInt_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudyLObjInt_delitem(PyJudyL *self, PyObject *key)
{
  
    /* Delete object -> int array */
    long success;
    PPvoid_t p;

    /* does something already exist? */
    p = JudyLGet(self->array, (Word_t) key, PJE0);
    if (p == NULL) {
      return 0;   /* Let the caller set the exception if appropriate */
    }
    /* decref and remove */
    Py_DECREF(key);
    
    success = JudyLDel(&(self->array), (Word_t) key, PJE0);
    if (!success) {
      /* is there any other way for delete to fail after a get? */
      PyErr_NoMemory();
      return -1;
    }
    return 1;

}

static PyObject *
PyJudyLObjInt_Del(PyJudyL *self, PyObject *key)
{
  int success;
  success = PyJudyLObjInt_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudyLObjInt_Get(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudyLObjInt_get(PyJudyL *self, PyObject *args)
{
  Word_t index;
  PPvoid_t p;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  index = (Word_t) key;;
  p = JudyLGet(self->array, index, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudyLObjInt_Count(PyJudyL *self)
{
  Word_t count;
  count = JudyLCount(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjInt_Count_from(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  count = JudyLCount(self->array, index, -1, PJE0);
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjInt_Count_to(PyJudyL *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjInt_Count_range(PyJudyL *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudyLObjInt_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = JudyLCount(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}

static PyObject *
PyJudyLObjInt_ByCount(PyJudyL *self, PyObject *key)
{
  PPvoid_t p;
  Word_t index;
  Word_t Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  p = JudyLByCount(self->array, Nth, &index, PJE0);
  if (p == NULL) {
    /* Not found; raise exception */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  /* Return the 2-ple of (index, value) */
  return PyJudyLObjInt_make_2ple(index, p);
}

static PyObject *
PyJudyLObjInt_FreeArray(PyJudyL *self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    Word_t i=0;
    p=JudyLFirst(self->array, &i, PJE0);
    while (p != NULL) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      p = JudyLNext(self->array, &i, PJE0);
    }
}
  JudyLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudyLObjInt_First(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  PPvoid_t p;
  PyObject *key=NULL;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  p = JudyLFirst(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjInt_make_2ple(index, p);
}

static PyObject *
PyJudyLObjInt_Next(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLNext(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudyLObjInt_make_2ple(index, p);
}

static PyObject *
PyJudyLObjInt_Last(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  p = JudyLLast(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjInt_make_2ple(index, p);
}

static PyObject *
PyJudyLObjInt_Prev(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;;
  p = JudyLPrev(self->array, &index, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudyLObjInt_make_2ple(index, p);
}


/* ******** */

static PyObject *
PyJudyLObjInt_FirstEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = JudyLFirstEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjInt_NextEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = JudyLNextEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjInt_LastEmpty(PyJudyL *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = JudyLLastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudyLObjInt_PrevEmpty(PyJudyL *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = JudyLPrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudyLObjInt_keys(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)index), (PyObject *)index));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLObjInt_values(PyJudyL *self)
{
  PyObject *v;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong((Word_t)(*p)));
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;
}

static PyObject *
PyJudyLObjInt_items(PyJudyL *self)
{
  PyObject *v, *tuple;
  Word_t n, index;
  PPvoid_t p;
  int i=0;

  n = JudyLCount(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  index = 0;
  p = JudyLFirst(self->array, &index, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudyL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudyLObjInt_make_2ple(index, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudyLNext(self->array, &index, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudyLObjInt_contains(PyJudyL *self, PyObject *key)
{
  Word_t index;
  Pvoid_t p;

  index = (Word_t) key;

  p = JudyLGet(self->array, (Word_t) index, PJE0);  
  return (p != NULL);
}

/* Meet the mapping protocol */
static int
PyJudyLObjInt_length(PyJudyL *self)
{
  /* XXX what if count > 2**31? */
  return JudyLCount(self->array, 0, -1, PJE0);
}

static PyObject *
PyJudyLObjInt_subscript(PyJudyL *self, PyObject *key)
{
  Word_t index;
  PPvoid_t p;

  index = (Word_t) key;
  p = JudyLGet(self->array, (Word_t) index, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static int
PyJudyLObjInt_ass_sub(PyJudyL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudyLObjInt_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
    /* Insert obj -> int */
    PPvoid_t p;
    Word_t val;

    if (!PyInt_CheckExact(value)) {
        PyErr_SetString(PyExc_ValueError, "an integer value is required");
        return -1;
    }
    val = PyInt_AS_LONG(value);
    
    /* See if the entry already exists */
    p = JudyLGet(self->array, (Word_t) key, PJE0);
    if (p != NULL) {
        /* no need to touch the refcount on the key */
        *((Word_t *)p) = val;
        return 0;
    }
    /* Does not exist so add it */
    p = JudyLIns(&(self->array), (Word_t) key, PJE0);
    if (p == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    Py_INCREF(key);
    *((Word_t *)p) = val;
    return 0;


  }
}


static PyMappingMethods PyJudyLObjInt_as_mapping = {
  (inquiry) PyJudyLObjInt_length,
  (binaryfunc) PyJudyLObjInt_subscript,
  (objobjargproc)PyJudyLObjInt_ass_sub,
};


/* Hack to implement "key in array" */
static PySequenceMethods PyJudyLObjInt_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudyLObjInt_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudyLObjInt_methods[] = {
  {"MemUsed", (PyCFunction) PyJudyLObjInt_MemUsed, METH_NOARGS, 
   "number of bytes of malloced memory used by this array"},
  {"Ins", (PyCFunction) PyJudyLObjInt_Ins, METH_VARARGS, 
   "insert a key and value into the array"},
  {"Del", (PyCFunction) PyJudyLObjInt_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudyLObjInt_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudyLObjInt_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudyLObjInt_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"Count_from", (PyCFunction) PyJudyLObjInt_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudyLObjInt_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudyLObjInt_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudyLObjInt_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudyLObjInt_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudyLObjInt_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudyLObjInt_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input key. "
   "If no input key, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudyLObjInt_Next, METH_O,
   "the next (key, value) tuple where the key is after the input key.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudyLObjInt_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input key. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudyLObjInt_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input key.  If "
   "there are no earlier tuples, raises StopIteration"},
  {"FirstEmpty", (PyCFunction) PyJudyLObjInt_FirstEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "after the input key. If no input, the first empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"NextEmpty", (PyCFunction) PyJudyLObjInt_NextEmpty, METH_O,
   "the location of the next empty key position (as a signed integer) after "
   "the input key. If no empty locations remain, raises StopIteration."},
  {"LastEmpty", (PyCFunction) PyJudyLObjInt_LastEmpty, METH_VARARGS,
   "the location of the first empty key position (as a signed integer) at or "
   "before the input key. If no input, the last empty position.  If no empty "
   "locations remain, raises StopIteration."},
  {"PrevEmpty", (PyCFunction) PyJudyLObjInt_PrevEmpty, METH_O,
   "the location of the previous empty key position (as a signed integer) before "
   "the input key. If no empty locations remain, raises StopIteration."},

  {"keys", (PyCFunction) PyJudyLObjInt_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudyLObjInt_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudyLObjInt_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudyLObjInt_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudyLObjInt_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudyLObjInt_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudyLObjInt_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input key and "
   "going up to but not including the second"},

  {"itervalues", (PyCFunction) PyJudyLObjInt_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudyLObjInt_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input key"},
  {"itervalues_to", (PyCFunction) PyJudyLObjInt_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input key"},
  {"itervalues_range", (PyCFunction) PyJudyLObjInt_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input key and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudyLObjInt_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudyLObjInt_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input key"},
  {"iteritems_to", (PyCFunction) PyJudyLObjInt_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input key"},
  {"iteritems_range", (PyCFunction) PyJudyLObjInt_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input key and going up to but not including the second "},

  {"riterkeys", (PyCFunction) PyJudyLObjInt_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudyLObjInt_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudyLObjInt_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudyLObjInt_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudyLObjInt_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudyLObjInt_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input key"},
  {"ritervalues_to", (PyCFunction) PyJudyLObjInt_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input key"},
  {"ritervalues_range", (PyCFunction) PyJudyLObjInt_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input key "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudyLObjInt_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudyLObjInt_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input key"},
  {"riteritems_to", (PyCFunction) PyJudyLObjInt_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input key"},
  {"riteritems_range", (PyCFunction) PyJudyLObjInt_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input key and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudyLObjInt_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  {"iterempty", (PyCFunction) PyJudyLObjInt_iterempty, METH_NOARGS,
   "iterate through all the possible empty keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudyLObjInt_iterempty_from, METH_O, 
   "iterate through all the possible empty keys (as signed integers) at or "
   "above the given input key"},
  {"iterempty_to", (PyCFunction) PyJudyLObjInt_iterempty_to, METH_O,
   "iterate through all the possible empty keys (as signed integers) up to "
   "but not including the given input key"},
  {"iterempty_range", (PyCFunction) PyJudyLObjInt_iterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudyLObjInt_riterempty, METH_NOARGS,
   "reverse iteration through all the possible empty keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudyLObjInt_riterempty_from, METH_O, 
   "reverse iteration through all the possible empty keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudyLObjInt_riterempty_to, METH_O,
   "reverse iteration through all the possible empty keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudyLObjInt_riterempty_range, METH_VARARGS,
   "iterate through all the possible empty keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},
  
  {NULL}
};

/* PyJudyLObjInt */
static PyTypeObject PyJudyLObjIntType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudyLObjInt",             /*tp_name*/
    sizeof(PyJudyL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudyLObjInt_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudyLObjInt_as_sequence,                         /*tp_as_sequence*/
    &PyJudyLObjInt_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudyL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudyLObjInt_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudyLObjInt_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudyLObjInt_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudyLObjInt_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  PyObject *result;  /* reusable result tuple for iteritems */
  Word_t index;
  Word_t stop;
  PyJudyL *container;   /* Set to NULL when iterator is exhausted */
} PyJudyLObjInt_iterobject;

static PyObject *
PyJudyLObjInt_iter_new(PyJudyL *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudyLObjInt_iterobject *it;

  it = PyObject_New(PyJudyLObjInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLObjIntIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudyLObjInt_iter_dealloc(PyJudyLObjInt_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudyLObjIntIter_iternextkey(PyJudyLObjInt_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudyLObjIntIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLObjIntIter_iternextvalue(PyJudyLObjInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudyLObjIntIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLObjIntIter_iternextitem(PyJudyLObjInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLNext(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLFirst(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (!key)
    return NULL;
  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLObjIntIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemiterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudyLObjInt_riter_new(PyJudyL *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudyLObjInt_iterobject *it;

  it = PyObject_New(PyJudyLObjInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudyLObjIntRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudyLObjIntRIter_iternextkey(PyJudyLObjInt_iterobject *it)
{
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudyLObjIntRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudyLObjIntRIter_iternextvalue(PyJudyLObjInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudyLObjIntRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-valueiterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudyLObjIntRIter_iternextitem(PyJudyLObjInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudyLPrev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    p = JudyLLast(it->container->array, &(it->index), PJE0);
  }
  if (!p ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  index = it->index;
  key = (Py_INCREF((PyObject *)index), (PyObject *)index);
  if (!key)
    return NULL;

  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudyLObjIntRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-itemriterator",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjIntRIter_iternextitem,    /* tp_iternext */
};

/***** Forward iteration over the empty keys *****/

static PyObject *PyJudyLObjInt_iterempty_next(PyJudyLObjInt_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLNextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLFirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLObjIntIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjInt_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudyLObjInt_riterempty_next(PyJudyLObjInt_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = JudyLPrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = JudyLLastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudyLObjIntRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudyLObjInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudyLObjInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudyLObjInt_riterempty_next,    /* tp_iternext */
};
/***************** PyJudy1Int **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudy1Int_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudy1IntIterKey_Type;
static PyObject *PyJudy1Int_iter_new(PyJudy1 *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudy1Int_iter(PyObject *container)
{
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iter",
		      0, -1, 0, &PyJudy1IntIterKey_Type);
}

static PyObject *
PyJudy1Int_iterkeys(PyObject *container)
{
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterkeys",
		      0, -1, 0, &PyJudy1IntIterKey_Type);
}

static PyObject *
PyJudy1Int_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterkeys_from",
		      index, -1, 0, &PyJudy1IntIterKey_Type);
}
static PyObject *
PyJudy1Int_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterkeys_to",
		      0, index, 1, &PyJudy1IntIterKey_Type);
}

static PyObject *
PyJudy1Int_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Int_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterkey_range",
		      start, end, 1, &PyJudy1IntIterKey_Type);
}

/**** itervalues, iteritems ****/

/* It would be silly to have this for boolean values since they   */
/* would all be 1.  I could implement such thing if there's       */
/* enough demand, or you could contribute a patch if you want it. */


/* Forward empty iteration */
extern PyTypeObject PyJudy1IntIterEmpty_Type;

static PyObject *PyJudy1Int_iterempty(PyObject *container)
{
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterempty",
		      0, -1, 0, &PyJudy1IntIterEmpty_Type);
}
static PyObject *PyJudy1Int_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterempty_from",
		      index, -1, 0, &PyJudy1IntIterEmpty_Type);
}
static PyObject *PyJudy1Int_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterempty_to",
		      0, index, 1, &PyJudy1IntIterEmpty_Type);
}
static PyObject *PyJudy1Int_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Int_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudy1Int_iter_new((PyJudy1 *)container, "iterempty_range",
		      start, end, 1, &PyJudy1IntIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudy1Int_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudy1IntRIterKey_Type;
static PyObject *PyJudy1Int_riter_new(PyJudy1 *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudy1Int_riter(PyObject *container)
{
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iter",
		      -1, 0, 0, &PyJudy1IntRIterKey_Type);
}

static PyObject *
PyJudy1Int_riterkeys(PyObject *container)
{
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterkeys",
		      -1, 0, 0, &PyJudy1IntRIterKey_Type);
}

static PyObject *
PyJudy1Int_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterkeys_from",
		      index, 0, 0, &PyJudy1IntRIterKey_Type);
}
static PyObject *
PyJudy1Int_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterkeys_to",
		      -1, index, 1, &PyJudy1IntRIterKey_Type);
}

static PyObject *
PyJudy1Int_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Int_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterkey_range",
		      start, end, 1, &PyJudy1IntRIterKey_Type);
}

/**** itervalues, iteritems ****/

/* It would be silly to have this for boolean values since they   */
/* would all be 1.  I could implement such thing if there's       */
/* enough demand, or you could contribute a patch if you want it. */


/* Forward empty iteration */
extern PyTypeObject PyJudy1IntRIterEmpty_Type;

static PyObject *PyJudy1Int_riterempty(PyObject *container)
{
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterempty",
		      -1, 0, 0, &PyJudy1IntRIterEmpty_Type);
}
static PyObject *PyJudy1Int_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterempty_from",
		      index, 0, 0, &PyJudy1IntRIterEmpty_Type);
}
static PyObject *PyJudy1Int_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterempty_to",
		      -1, index, 1, &PyJudy1IntRIterEmpty_Type);
}
static PyObject *PyJudy1Int_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Int_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudy1Int_riter_new((PyJudy1 *)container, "iterempty_range",
		      start, end, 1, &PyJudy1IntRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudy1Int_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *start_index = index;

  key = end_key;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

static void
PyJudy1Int_dealloc(PyJudy1* self)
{
  
  Judy1FreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudy1Int_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudy1 *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudy1 *)PyObject_New(PyJudy1, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudy1Int_MemUsed(PyJudy1 *self)
{
  Word_t size;
  size = Judy1MemUsed(self->array);
  return as_unsigned(size);
}


static PyObject *
PyJudy1Int_Set(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Set(&(self->array), index, PJE0);

  if (rc == 0) {
    /* Already in the array - don't need to incr again */
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    ;
    Py_INCREF(Py_True);
    return Py_True;
  }
}

static PyObject *
PyJudy1Int_add(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Set(&(self->array), index, PJE0);

  if (rc != 0) {
    ;
  }
  Py_INCREF(Py_None);
  return Py_None;
}

static PyObject *
PyJudy1Int_Unset(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Unset(&(self->array), index, PJE0);
  
  if (rc == 0) {
    /* was already unset */
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    ;
    Py_INCREF(Py_True);
    return Py_True;
  }
}

static PyObject *
PyJudy1Int_remove(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Unset(&(self->array), index, PJE0);
  
  if (rc == 0) {
    /* was already unset */
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  ;
  Py_INCREF(Py_None);
  return Py_None;
}



static PyObject *
PyJudy1Int_Test(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Test(self->array, index, PJE0);
  
  if (rc == 0) {
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    Py_INCREF(Py_True);
    return Py_True;
  }
}



static PyObject *
PyJudy1Int_Count(PyJudy1 *self)
{
  Word_t count;
  count = Judy1Count(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}
static PyObject *
PyJudy1Int_Count_from(PyJudy1 *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  count = Judy1Count(self->array, index, -1, PJE0);
  return as_unsigned(count);
}
static PyObject *
PyJudy1Int_Count_to(PyJudy1 *self, PyObject *key)
{
  Word_t count, index;
  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = Judy1Count(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}
static PyObject *
PyJudy1Int_Count_range(PyJudy1 *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudy1Int_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = Judy1Count(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}


static PyObject *
PyJudy1Int_ByCount(PyJudy1 *self, PyObject *key)
{
  int rc;
  Word_t index;
  long Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  rc = Judy1ByCount(self->array, (Word_t) Nth, &index, PJE0);
  if (rc == 0) {
    /* Not found */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  } else {
    return PyInt_FromLong(index);
  }
}

static PyObject *
PyJudy1Int_FreeArray(PyJudy1 *self)
{
  
  Judy1FreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudy1Int_First(PyJudy1 *self, PyObject *args)
{
  Word_t index = 0;
  PyObject *key=NULL;
  int rc;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = Judy1First(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = PyInt_FromLong(index);
    ;
    return key;
  }
}

static PyObject *
PyJudy1Int_Next(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = Judy1Next(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = PyInt_FromLong(index);
    ;
    return key;
  }
}

static PyObject *
PyJudy1Int_Last(PyJudy1 *self, PyObject *args)
{
  Word_t index = -1;
  PyObject *key = NULL;
  int rc;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = Judy1Last(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = PyInt_FromLong(index);
    ;
    return key;
  }
}

static PyObject *
PyJudy1Int_Prev(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = Judy1Prev(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = PyInt_FromLong(index);
    ;
    return key;
  }
}


/* ******** */

static PyObject *
PyJudy1Int_FirstEmpty(PyJudy1 *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = Judy1FirstEmpty(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Int_NextEmpty(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = Judy1NextEmpty(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Int_LastEmpty(PyJudy1 *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  }

  rc = Judy1LastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Int_PrevEmpty(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;
  rc = Judy1PrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudy1Int_keys(PyJudy1 *self)
{
  PyObject *v;
  Word_t n, index;
  int i=0, rc;

  n = Judy1Count(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  rc = Judy1First(self->array, &index, PJE0);
  while (i<n) {
    if (!rc) {
      PyErr_SetString(PyExc_SystemError,
		      "Judy1 size changed while creating list of keys");
      Py_DECREF(v);
      /* XXX Memory leak here? */
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong(index));
    i++;
    rc = Judy1Next(self->array, &index, PJE0);
  }
  return v;
}

int
PyJudy1Int_contains(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  
  if (!PyInt_CheckExact(key)) {
    PyErr_SetString(PyExc_ValueError, "an integer key is required");
    return NULL;
  }
  index = PyInt_AS_LONG(key);
;

  rc = Judy1Test(self->array, (Word_t) index, PJE0);
  return (rc != 0);
}

/* Hack to implement "key in array" */
static PySequenceMethods PyJudy1Int_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudy1Int_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};

static PyMethodDef PyJudy1Int_methods[] = {
  {"MemUsed", (PyCFunction) PyJudy1Int_MemUsed, METH_NOARGS,
   "number of bytes of malloced memory used by this array"},
  {"Set", (PyCFunction) PyJudy1Int_Set, METH_O,
   "set the corresponding bit to 1"},
  {"add", (PyCFunction) PyJudy1Int_add, METH_O,
   "add the object to the set"},
  {"Unset", (PyCFunction) PyJudy1Int_Unset, METH_O,
   "set the corresponding bit to 0"},
  {"remove", (PyCFunction) PyJudy1Int_remove, METH_O,
   "remove the object from the set"},
  {"Test", (PyCFunction) PyJudy1Int_Test, METH_O,
   "return True if the bit is set, else False"},
  {"Count", (PyCFunction) PyJudy1Int_Count, METH_NOARGS, 
   "total number of bits set in the array"},
  {"__len__", (PyCFunction) PyJudy1Int_Count, METH_NOARGS, "__len__"},
  {"Count_from", (PyCFunction) PyJudy1Int_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudy1Int_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudy1Int_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudy1Int_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudy1Int_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudy1Int_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudy1Int_First, METH_VARARGS,
   "the first set key in the array where the key is at or after the input key. "
   "If no input is given, returns the first key in the array.  If there are no "
   "set keys at or after the input key, raises StopIteration"},
  {"Next", (PyCFunction) PyJudy1Int_Next, METH_O,
   "the next set key in the array after the given input key.  If there are no "
   "later set keys, raises StopIteration"},
  {"Last", (PyCFunction) PyJudy1Int_Last, METH_VARARGS, 
   "the last set key in the array where the key is at or before the input key. "
   "If no input key is given, returns the last key in the array.  If there are no "
   "set keys at or before the input, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudy1Int_Prev, METH_O, 
   "the previous set key in the array where the key is before the given input key. "
   "If there are no earlier keys, raises StopIteration"},

  {"FirstEmpty", (PyCFunction) PyJudy1Int_FirstEmpty, METH_VARARGS,
   "the first unset key in the array where the key is at or after the input key. "
   "If no input key is given, returns the first key in the array.  If there are no "
   "unset keys at or after the key, raises StopIteration"},
  {"NextEmpty", (PyCFunction) PyJudy1Int_NextEmpty, METH_O,
   "the next unset key in the array after the given input key.  If there are no "
   "later unset keys, raises StopIteration"},
  {"LastEmpty", (PyCFunction) PyJudy1Int_LastEmpty, METH_VARARGS,
   "the last unset key in the array where the key is at or before the input key. "
   "If no input key is given, returns the last key in the array.  If there are no "
   "unset keys at or before the input, raises StopIteration"},
  {"PrevEmpty", (PyCFunction) PyJudy1Int_PrevEmpty, METH_O,
   "the previous unset key in the array where the key is before the given input key. "
   "If there are no earlier keys, raises StopIteration"},

  {"keys", (PyCFunction) PyJudy1Int_keys, METH_NOARGS,
   "a list of all set keys"},
  {"__contains__", (PyCFunction) PyJudy1Int_contains, METH_O,
   "True if the object is set, otherwise False"},

  {"iterkeys", (PyCFunction) PyJudy1Int_iterkeys, METH_NOARGS,
   "iterate through all set keys"},
  {"iterkeys_from", (PyCFunction) PyJudy1Int_iterkeys_from, METH_O,
   "iterate through the set keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudy1Int_iterkeys_to, METH_O,
   "iterate through the set keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudy1Int_iterkeys_range, METH_VARARGS,
   "iterate through the set keys starting at or after the first input and going up "
   "to but not including the second"},


  {"riterkeys", (PyCFunction) PyJudy1Int_riterkeys, METH_NOARGS,
   "reverse iteration through all the set keys"},
  {"riterkeys_from", (PyCFunction) PyJudy1Int_riterkeys_from, METH_O,
   "reverse iteration through the set keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudy1Int_riterkeys_to, METH_O,
   "reverse iteration through the set keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudy1Int_riterkeys_range, METH_VARARGS,
   "reverse iteration through the set keys starting at or before the first input "
   "and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudy1Int_riter, METH_NOARGS, 
   "reverse iteration through all the set keys"},

  {"iterempty", (PyCFunction) PyJudy1Int_iterempty, METH_NOARGS,
   "iterate through all the unset keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudy1Int_iterempty_from, METH_O, 
   "iterate through all unset keys (as signed integers) at or "
   "above the input key"},
  {"iterempty_to", (PyCFunction) PyJudy1Int_iterempty_to, METH_O,
   "iterate through all the unset keys (as signed integers) up to "
   "but not including the input key"},
  {"iterempty_range", (PyCFunction) PyJudy1Int_iterempty_range, METH_VARARGS,
   "iterate through all the unset keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudy1Int_riterempty, METH_NOARGS,
   "reverse iteration through all the unset keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudy1Int_riterempty_from, METH_O, 
   "reverse iteration through all the unset keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudy1Int_riterempty_to, METH_O,
   "reverse iteration through all the unset keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudy1Int_riterempty_range, METH_VARARGS,
   "iterate through all the unset keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},

  {NULL}
};

/* PyJudy1Int */
static PyTypeObject PyJudy1IntType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudy1Int",             /*tp_name*/
    sizeof(PyJudy1), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudy1Int_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudy1Int_as_sequence,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "Judy1 arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudy1Int_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudy1Int_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudy1Int_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudy1Int_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  Word_t index;
  Word_t stop;
  PyJudy1 *container;   /* Set to NULL when iterator is exhausted */
} PyJudy1Int_iterobject;

static PyObject *
PyJudy1Int_iter_new(PyJudy1 *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudy1Int_iterobject *it;

  it = PyObject_New(PyJudy1Int_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  return (PyObject *)it;
}

static void
PyJudy1Int_iter_dealloc(PyJudy1Int_iterobject *it)
{
  Py_XDECREF(it->container);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudy1IntIter_iternextkey(PyJudy1Int_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1Next(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1First(it->container->array, &(it->index), PJE0);
  }
  if (!rc ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1IntIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudy1Int_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Int_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1IntIter_iternextkey,    /* tp_iternext */
};


/******* reverse iteration *******/

static PyObject *
PyJudy1Int_riter_new(PyJudy1 *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudy1Int_iterobject *it;

  it = PyObject_New(PyJudy1Int_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudy1IntRIter_iternextkey(PyJudy1Int_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1Prev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1Last(it->container->array, &(it->index), PJE0);
  }
  if (!rc ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1IntRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudy1Int_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Int_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1IntRIter_iternextkey,    /* tp_iternext */
};


/***** Forward iteration over the empty keys *****/

static PyObject *PyJudy1Int_iterempty_next(PyJudy1Int_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1NextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1FirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1IntIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudy1Int_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Int_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1Int_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudy1Int_riterempty_next(PyJudy1Int_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1PrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1LastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1IntRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudy1Int_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Int_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1Int_riterempty_next,    /* tp_iternext */
};
/***************** PyJudy1Obj **************/
/* Forward declarations for forward iteration */

static PyObject *PyJudy1Obj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudy1ObjIterKey_Type;
static PyObject *PyJudy1Obj_iter_new(PyJudy1 *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudy1Obj_iter(PyObject *container)
{
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iter",
		      0, -1, 0, &PyJudy1ObjIterKey_Type);
}

static PyObject *
PyJudy1Obj_iterkeys(PyObject *container)
{
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterkeys",
		      0, -1, 0, &PyJudy1ObjIterKey_Type);
}

static PyObject *
PyJudy1Obj_iterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterkeys_from",
		      index, -1, 0, &PyJudy1ObjIterKey_Type);
}
static PyObject *
PyJudy1Obj_iterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterkeys_to",
		      0, index, 1, &PyJudy1ObjIterKey_Type);
}

static PyObject *
PyJudy1Obj_iterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Obj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterkey_range",
		      start, end, 1, &PyJudy1ObjIterKey_Type);
}

/**** itervalues, iteritems ****/

/* It would be silly to have this for boolean values since they   */
/* would all be 1.  I could implement such thing if there's       */
/* enough demand, or you could contribute a patch if you want it. */


/* Forward empty iteration */
extern PyTypeObject PyJudy1ObjIterEmpty_Type;

static PyObject *PyJudy1Obj_iterempty(PyObject *container)
{
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterempty",
		      0, -1, 0, &PyJudy1ObjIterEmpty_Type);
}
static PyObject *PyJudy1Obj_iterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterempty_from",
		      index, -1, 0, &PyJudy1ObjIterEmpty_Type);
}
static PyObject *PyJudy1Obj_iterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterempty_to",
		      0, index, 1, &PyJudy1ObjIterEmpty_Type);
}
static PyObject *PyJudy1Obj_iterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Obj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudy1Obj_iter_new((PyJudy1 *)container, "iterempty_range",
		      start, end, 1, &PyJudy1ObjIterEmpty_Type);
}
/* Forward declarations for reverse iteration */

static PyObject *PyJudy1Obj_parse_range(PyObject *args, char *name,
				 Word_t *start_index, Word_t *end_index);
extern PyTypeObject PyJudy1ObjRIterKey_Type;
static PyObject *PyJudy1Obj_riter_new(PyJudy1 *, const char *,
			      Word_t start, Word_t end, int has_limit,
                              PyTypeObject *);

static PyObject *
PyJudy1Obj_riter(PyObject *container)
{
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iter",
		      -1, 0, 0, &PyJudy1ObjRIterKey_Type);
}

static PyObject *
PyJudy1Obj_riterkeys(PyObject *container)
{
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterkeys",
		      -1, 0, 0, &PyJudy1ObjRIterKey_Type);
}

static PyObject *
PyJudy1Obj_riterkeys_from(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterkeys_from",
		      index, 0, 0, &PyJudy1ObjRIterKey_Type);
}
static PyObject *
PyJudy1Obj_riterkeys_to(PyObject *container, PyObject *key)
{
  Word_t index;
  
  index = (Word_t) key;;
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterkeys_to",
		      -1, index, 1, &PyJudy1ObjRIterKey_Type);
}

static PyObject *
PyJudy1Obj_riterkeys_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Obj_parse_range(args, "iterkeys_range", &start, &end))
    return NULL;
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterkey_range",
		      start, end, 1, &PyJudy1ObjRIterKey_Type);
}

/**** itervalues, iteritems ****/

/* It would be silly to have this for boolean values since they   */
/* would all be 1.  I could implement such thing if there's       */
/* enough demand, or you could contribute a patch if you want it. */


/* Forward empty iteration */
extern PyTypeObject PyJudy1ObjRIterEmpty_Type;

static PyObject *PyJudy1Obj_riterempty(PyObject *container)
{
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterempty",
		      -1, 0, 0, &PyJudy1ObjRIterEmpty_Type);
}
static PyObject *PyJudy1Obj_riterempty_from(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterempty_from",
		      index, 0, 0, &PyJudy1ObjRIterEmpty_Type);
}
static PyObject *PyJudy1Obj_riterempty_to(PyObject *container, PyObject *key)
{
  Word_t index;
  index = (Word_t) key;;
  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterempty_to",
		      -1, index, 1, &PyJudy1ObjRIterEmpty_Type);
}
static PyObject *PyJudy1Obj_riterempty_range(PyObject *container, PyObject *args)
{
  Word_t start, end;
  if (!PyJudy1Obj_parse_range(args, "iterempty_range", &start, &end))
    return NULL;

  return PyJudy1Obj_riter_new((PyJudy1 *)container, "iterempty_range",
		      start, end, 1, &PyJudy1ObjRIterEmpty_Type);
}
/** Helper function to parse ranges  **/

static PyObject *
PyJudy1Obj_parse_range(PyObject *args, char *name,
		Word_t *start_index, Word_t *end_index)
{
  PyObject *start_key, *end_key, *key;
  Word_t index;
  if (!PyArg_UnpackTuple(args, name, 2, 2, &start_key, &end_key))
    return NULL;
  
  key = start_key;
  index = (Word_t) key;;
  *start_index = index;

  key = end_key;
  index = (Word_t) key;;
  *end_index = index;
  
  /* I need to return something which isn't NULL */
  return args;
}

static void
PyJudy1Obj_dealloc(PyJudy1* self)
{
  {
    int rc;
    PyObject *obj;
    Word_t i=0;
    rc=Judy1First(self->array, &i, PJE0);
    while (rc) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      rc = Judy1Next(self->array, &i, PJE0);
    }
}
  Judy1FreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudy1Obj_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudy1 *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudy1 *)PyObject_New(PyJudy1, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  return (PyObject *)self;
}

static PyObject *
PyJudy1Obj_MemUsed(PyJudy1 *self)
{
  Word_t size;
  size = Judy1MemUsed(self->array);
  return as_unsigned(size);
}


static PyObject *
PyJudy1Obj_Set(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;

  rc = Judy1Set(&(self->array), index, PJE0);

  if (rc == 0) {
    /* Already in the array - don't need to incr again */
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    Py_INCREF(key);
    Py_INCREF(Py_True);
    return Py_True;
  }
}

static PyObject *
PyJudy1Obj_add(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;

  rc = Judy1Set(&(self->array), index, PJE0);

  if (rc != 0) {
    Py_INCREF(key);
  }
  Py_INCREF(Py_None);
  return Py_None;
}

static PyObject *
PyJudy1Obj_Unset(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  index = (Word_t) key;;

  rc = Judy1Unset(&(self->array), index, PJE0);
  
  if (rc == 0) {
    /* was already unset */
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    Py_DECREF(key);
    Py_INCREF(Py_True);
    return Py_True;
  }
}

static PyObject *
PyJudy1Obj_remove(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  index = (Word_t) key;;

  rc = Judy1Unset(&(self->array), index, PJE0);
  
  if (rc == 0) {
    /* was already unset */
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  Py_DECREF(key);
  Py_INCREF(Py_None);
  return Py_None;
}



static PyObject *
PyJudy1Obj_Test(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;
  
  index = (Word_t) key;;

  rc = Judy1Test(self->array, index, PJE0);
  
  if (rc == 0) {
    Py_INCREF(Py_False);
    return Py_False;
  } else {
    Py_INCREF(Py_True);
    return Py_True;
  }
}



static PyObject *
PyJudy1Obj_Count(PyJudy1 *self)
{
  Word_t count;
  count = Judy1Count(self->array, 0, -1, PJE0);
  return as_unsigned(count);
}
static PyObject *
PyJudy1Obj_Count_from(PyJudy1 *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  count = Judy1Count(self->array, index, -1, PJE0);
  return as_unsigned(count);
}
static PyObject *
PyJudy1Obj_Count_to(PyJudy1 *self, PyObject *key)
{
  Word_t count, index;
  index = (Word_t) key;;
  /* in the Python manner, exclude the final */
  if (index == 0) {
    count = 0;
  } else {
    count = Judy1Count(self->array, 0, index-1, PJE0);
  }
  return as_unsigned(count);
}
static PyObject *
PyJudy1Obj_Count_range(PyJudy1 *self, PyObject *args)
{
  Word_t count, start, end;
  if (!PyJudy1Obj_parse_range(args, "Count_range", &start, &end))
    return NULL;
  if (end == 0) {
    count = 0;
  } else {
    count = Judy1Count(self->array, start, end-1, PJE0);
  }
  return as_unsigned(count);
}


static PyObject *
PyJudy1Obj_ByCount(PyJudy1 *self, PyObject *key)
{
  int rc;
  Word_t index;
  long Nth;
  /* XXX Need to allow Nth >= LONG_MAX */
  Nth = PyInt_AsLong(key);
  if (Nth == -1 && PyErr_Occurred())
    return NULL;
  rc = Judy1ByCount(self->array, (Word_t) Nth, &index, PJE0);
  if (rc == 0) {
    /* Not found */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  } else {
    return (Py_INCREF((PyObject *)index), (PyObject *)index);
  }
}

static PyObject *
PyJudy1Obj_FreeArray(PyJudy1 *self)
{
  {
    int rc;
    PyObject *obj;
    Word_t i=0;
    rc=Judy1First(self->array, &i, PJE0);
    while (rc) {
      obj = (PyObject *) i;
      Py_DECREF(obj);
      rc = Judy1Next(self->array, &i, PJE0);
    }
}
  Judy1FreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudy1Obj_First(PyJudy1 *self, PyObject *args)
{
  Word_t index = 0;
  PyObject *key=NULL;
  int rc;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = Judy1First(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = (Py_INCREF((PyObject *)index), (PyObject *)index);
    Py_INCREF(key);
    return key;
  }
}

static PyObject *
PyJudy1Obj_Next(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = Judy1Next(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = (Py_INCREF((PyObject *)index), (PyObject *)index);
    Py_INCREF(key);
    return key;
  }
}

static PyObject *
PyJudy1Obj_Last(PyJudy1 *self, PyObject *args)
{
  Word_t index = -1;
  PyObject *key = NULL;
  int rc;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = Judy1Last(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = (Py_INCREF((PyObject *)index), (PyObject *)index);
    Py_INCREF(key);
    return key;
  }
}

static PyObject *
PyJudy1Obj_Prev(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = Judy1Prev(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  } else {
    key = (Py_INCREF((PyObject *)index), (PyObject *)index);
    Py_INCREF(key);
    return key;
  }
}


/* ******** */

static PyObject *
PyJudy1Obj_FirstEmpty(PyJudy1 *self, PyObject *args)
{
  Word_t index = 0;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "FirstEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = Judy1FirstEmpty(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Obj_NextEmpty(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = Judy1NextEmpty(self->array, &index, PJE0);
  if (rc == 0) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Obj_LastEmpty(PyJudy1 *self, PyObject *args)
{
  Word_t index = -1;
  int rc;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "LastEmpty", 0, 1, &key))
    return NULL;
  if (key) {
    index = (Word_t) key;;
  }

  rc = Judy1LastEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

static PyObject *
PyJudy1Obj_PrevEmpty(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;
  rc = Judy1PrevEmpty(self->array, &index, PJE0);
  if (!rc) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

/* Python object adapters */

static PyObject *
PyJudy1Obj_keys(PyJudy1 *self)
{
  PyObject *v;
  Word_t n, index;
  int i=0, rc;

  n = Judy1Count(self->array, 0, -1, PJE0);
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index = 0;
  rc = Judy1First(self->array, &index, PJE0);
  while (i<n) {
    if (!rc) {
      PyErr_SetString(PyExc_SystemError,
		      "Judy1 size changed while creating list of keys");
      Py_DECREF(v);
      /* XXX Memory leak here? */
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)index), (PyObject *)index));
    i++;
    rc = Judy1Next(self->array, &index, PJE0);
  }
  return v;
}

int
PyJudy1Obj_contains(PyJudy1 *self, PyObject *key)
{
  Word_t index;
  int rc;

  index = (Word_t) key;;

  rc = Judy1Test(self->array, (Word_t) index, PJE0);
  return (rc != 0);
}

/* Hack to implement "key in array" */
static PySequenceMethods PyJudy1Obj_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudy1Obj_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};

static PyMethodDef PyJudy1Obj_methods[] = {
  {"MemUsed", (PyCFunction) PyJudy1Obj_MemUsed, METH_NOARGS,
   "number of bytes of malloced memory used by this array"},
  {"Set", (PyCFunction) PyJudy1Obj_Set, METH_O,
   "set the corresponding bit to 1"},
  {"add", (PyCFunction) PyJudy1Obj_add, METH_O,
   "add the object to the set"},
  {"Unset", (PyCFunction) PyJudy1Obj_Unset, METH_O,
   "set the corresponding bit to 0"},
  {"remove", (PyCFunction) PyJudy1Obj_remove, METH_O,
   "remove the object from the set"},
  {"Test", (PyCFunction) PyJudy1Obj_Test, METH_O,
   "return True if the bit is set, else False"},
  {"Count", (PyCFunction) PyJudy1Obj_Count, METH_NOARGS, 
   "total number of bits set in the array"},
  {"__len__", (PyCFunction) PyJudy1Obj_Count, METH_NOARGS, "__len__"},
  {"Count_from", (PyCFunction) PyJudy1Obj_Count_from, METH_O,
   "number of elements between the given key and the end; including the key"},
  {"Count_to", (PyCFunction) PyJudy1Obj_Count_to, METH_O,
   "number of elements from the beginning to the given key; excluding the key"},
  {"Count_range", (PyCFunction) PyJudy1Obj_Count_range, METH_VARARGS,
   "number of elements between the start and end keys; excluding the end key"},

  {"ByCount", (PyCFunction) PyJudy1Obj_ByCount, METH_O,
   "the Nth (key, value) tuple; N==1 is the first tuple"},

  {"FreeArray", (PyCFunction) PyJudy1Obj_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudy1Obj_FreeArray, METH_NOARGS,
   "free the entire array"},

  {"First", (PyCFunction) PyJudy1Obj_First, METH_VARARGS,
   "the first set key in the array where the key is at or after the input key. "
   "If no input is given, returns the first key in the array.  If there are no "
   "set keys at or after the input key, raises StopIteration"},
  {"Next", (PyCFunction) PyJudy1Obj_Next, METH_O,
   "the next set key in the array after the given input key.  If there are no "
   "later set keys, raises StopIteration"},
  {"Last", (PyCFunction) PyJudy1Obj_Last, METH_VARARGS, 
   "the last set key in the array where the key is at or before the input key. "
   "If no input key is given, returns the last key in the array.  If there are no "
   "set keys at or before the input, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudy1Obj_Prev, METH_O, 
   "the previous set key in the array where the key is before the given input key. "
   "If there are no earlier keys, raises StopIteration"},

  {"FirstEmpty", (PyCFunction) PyJudy1Obj_FirstEmpty, METH_VARARGS,
   "the first unset key in the array where the key is at or after the input key. "
   "If no input key is given, returns the first key in the array.  If there are no "
   "unset keys at or after the key, raises StopIteration"},
  {"NextEmpty", (PyCFunction) PyJudy1Obj_NextEmpty, METH_O,
   "the next unset key in the array after the given input key.  If there are no "
   "later unset keys, raises StopIteration"},
  {"LastEmpty", (PyCFunction) PyJudy1Obj_LastEmpty, METH_VARARGS,
   "the last unset key in the array where the key is at or before the input key. "
   "If no input key is given, returns the last key in the array.  If there are no "
   "unset keys at or before the input, raises StopIteration"},
  {"PrevEmpty", (PyCFunction) PyJudy1Obj_PrevEmpty, METH_O,
   "the previous unset key in the array where the key is before the given input key. "
   "If there are no earlier keys, raises StopIteration"},

  {"keys", (PyCFunction) PyJudy1Obj_keys, METH_NOARGS,
   "a list of all set keys"},
  {"__contains__", (PyCFunction) PyJudy1Obj_contains, METH_O,
   "True if the object is set, otherwise False"},

  {"iterkeys", (PyCFunction) PyJudy1Obj_iterkeys, METH_NOARGS,
   "iterate through all set keys"},
  {"iterkeys_from", (PyCFunction) PyJudy1Obj_iterkeys_from, METH_O,
   "iterate through the set keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudy1Obj_iterkeys_to, METH_O,
   "iterate through the set keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudy1Obj_iterkeys_range, METH_VARARGS,
   "iterate through the set keys starting at or after the first input and going up "
   "to but not including the second"},


  {"riterkeys", (PyCFunction) PyJudy1Obj_riterkeys, METH_NOARGS,
   "reverse iteration through all the set keys"},
  {"riterkeys_from", (PyCFunction) PyJudy1Obj_riterkeys_from, METH_O,
   "reverse iteration through the set keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudy1Obj_riterkeys_to, METH_O,
   "reverse iteration through the set keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudy1Obj_riterkeys_range, METH_VARARGS,
   "reverse iteration through the set keys starting at or before the first input "
   "and going down to but not including the second"},

  {"__reversed__", (PyCFunction) PyJudy1Obj_riter, METH_NOARGS, 
   "reverse iteration through all the set keys"},

  {"iterempty", (PyCFunction) PyJudy1Obj_iterempty, METH_NOARGS,
   "iterate through all the unset keys (as signed integers)"},
  {"iterempty_from", (PyCFunction) PyJudy1Obj_iterempty_from, METH_O, 
   "iterate through all unset keys (as signed integers) at or "
   "above the input key"},
  {"iterempty_to", (PyCFunction) PyJudy1Obj_iterempty_to, METH_O,
   "iterate through all the unset keys (as signed integers) up to "
   "but not including the input key"},
  {"iterempty_range", (PyCFunction) PyJudy1Obj_iterempty_range, METH_VARARGS,
   "iterate through all the unset keys (as signed integers) starting "
   "at or above the first input key and going up to but not including the second"},

  {"riterempty", (PyCFunction) PyJudy1Obj_riterempty, METH_NOARGS,
   "reverse iteration through all the unset keys (as signed integers)"},
  {"riterempty_from", (PyCFunction) PyJudy1Obj_riterempty_from, METH_O, 
   "reverse iteration through all the unset keys (as signed integers) "
   "at or below the given input key"},
  {"riterempty_to", (PyCFunction) PyJudy1Obj_riterempty_to, METH_O,
   "reverse iteration through all the unset keys (as signed integers) "
   "down to but not including the given input key"},
  {"riterempty_range", (PyCFunction) PyJudy1Obj_riterempty_range, METH_VARARGS,
   "iterate through all the unset keys (as signed integers) starting "
   "at or below the first input key and going down to but not including the second"},

  {NULL}
};

/* PyJudy1Obj */
static PyTypeObject PyJudy1ObjType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudy1Obj",             /*tp_name*/
    sizeof(PyJudy1), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudy1Obj_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudy1Obj_as_sequence,                         /*tp_as_sequence*/
    0,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "Judy1 arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudy1Obj_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudy1Obj_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudy1Obj_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudy1Obj_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  short has_limit;
  Word_t index;
  Word_t stop;
  PyJudy1 *container;   /* Set to NULL when iterator is exhausted */
} PyJudy1Obj_iterobject;

static PyObject *
PyJudy1Obj_iter_new(PyJudy1 *container, const char *name,
	     Word_t start, Word_t end, int has_limit,
	     PyTypeObject *itertype)
{
  PyJudy1Obj_iterobject *it;

  it = PyObject_New(PyJudy1Obj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  return (PyObject *)it;
}

static void
PyJudy1Obj_iter_dealloc(PyJudy1Obj_iterobject *it)
{
  Py_XDECREF(it->container);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudy1ObjIter_iternextkey(PyJudy1Obj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1Next(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1First(it->container->array, &(it->index), PJE0);
  }
  if (!rc ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudy1ObjIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyiterator",              /* tp_name */
        sizeof(PyJudy1Obj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Obj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1ObjIter_iternextkey,    /* tp_iternext */
};


/******* reverse iteration *******/

static PyObject *
PyJudy1Obj_riter_new(PyJudy1 *container, const char *name,
	      Word_t start, Word_t end, int has_limit,
	      PyTypeObject *itertype)
{
  PyJudy1Obj_iterobject *it;

  it = PyObject_New(PyJudy1Obj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->found_first = 0;
  it->index = start;
  it->stop = end;
  it->has_limit = has_limit;

  Py_INCREF(container);
  it->container = container;

  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudy1ObjRIter_iternextkey(PyJudy1Obj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1Prev(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1Last(it->container->array, &(it->index), PJE0);
  }
  if (!rc ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  return (Py_INCREF((PyObject *)index), (PyObject *)index);
}

PyTypeObject PyJudy1ObjRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-keyriterator",              /* tp_name */
        sizeof(PyJudy1Obj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Obj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1ObjRIter_iternextkey,    /* tp_iternext */
};


/***** Forward iteration over the empty keys *****/

static PyObject *PyJudy1Obj_iterempty_next(PyJudy1Obj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1NextEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1FirstEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index >= it->stop)
      ) { /* Reached the upper limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;

  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1ObjIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-emptyiter",              /* tp_name */
        sizeof(PyJudy1Obj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Obj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1Obj_iterempty_next,       /* tp_iternext */
};


/***** Reverse iteration over the empty keys *****/

static PyObject *PyJudy1Obj_riterempty_next(PyJudy1Obj_iterobject *it)
{
  int rc;
  Word_t index;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    rc = Judy1PrevEmpty(it->container->array, &(it->index), PJE0);
  } else {
    it->found_first = 1;
    rc = Judy1LastEmpty(it->container->array, &(it->index), PJE0);
  }
  if (rc == 0 ||  /* Reached the end */
      (it->has_limit && it->index <= it->stop)
      ) { /* Reached the lower limit */ 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  index = it->index;
  /* This can only return an integer - it makes no sense otherwise */
  /* For that matter, this function makes no sense for object keys. */
  return PyInt_FromLong(index);
}

PyTypeObject PyJudy1ObjRIterEmpty_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudyl-remptyiter",              /* tp_name */
        sizeof(PyJudy1Obj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudy1Obj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudy1Obj_riterempty_next,    /* tp_iternext */
};
/***************** PyJudySLInt **************/
/* Forward declarations for forward iteration */

extern PyTypeObject PyJudySLIntIterKey_Type;
extern PyTypeObject PyJudySLIntIterValue_Type;
extern PyTypeObject PyJudySLIntIterItem_Type;
static PyObject *PyJudySLInt_iter_new(PyJudySL *, const char *,
			      PyObject *start, PyObject *end,
                              PyTypeObject *);

static PyObject *
PyJudySLInt_iter(PyObject *container)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iter",
		      NULL, NULL, &PyJudySLIntIterKey_Type);
}

static PyObject *
PyJudySLInt_iterkeys(PyObject *container)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iterkeys",
		      NULL, NULL, &PyJudySLIntIterKey_Type);
}

static PyObject *
PyJudySLInt_iterkeys_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iterkeys_from",
		      key, NULL, &PyJudySLIntIterKey_Type);
}
static PyObject *
PyJudySLInt_iterkeys_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iterkeys_to",
		      NULL, key, &PyJudySLIntIterKey_Type);
}

static PyObject *
PyJudySLInt_iterkeys_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_iter_new((PyJudySL *)container, "iterkey_range",
		      start, end, &PyJudySLIntIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudySLInt_itervalues(PyObject *container)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "itervalues",
		      NULL, NULL, &PyJudySLIntIterValue_Type);
}
static PyObject *
PyJudySLInt_itervalues_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "itervalues_to",
		      key, NULL, &PyJudySLIntIterValue_Type);

}
static PyObject *
PyJudySLInt_itervalues_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "itervalues_to",
		      NULL, key, &PyJudySLIntIterValue_Type);

}
static PyObject *
PyJudySLInt_itervalues_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_iter_new((PyJudySL *)container, "itervalues_range",
		      start, end, &PyJudySLIntIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudySLInt_iteritems(PyObject *container)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iteritems",
		      NULL, NULL, &PyJudySLIntIterItem_Type);
}
static PyObject *
PyJudySLInt_iteritems_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iteritems_to",
		      key, NULL, &PyJudySLIntIterItem_Type);

}
static PyObject *
PyJudySLInt_iteritems_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_iter_new((PyJudySL *)container, "iteritems_to",
		      NULL, key, &PyJudySLIntIterItem_Type);

}
static PyObject *
PyJudySLInt_iteritems_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_iter_new((PyJudySL *)container, "iteritems_range",
		      start, end, &PyJudySLIntIterItem_Type);

}
/* Forward declarations for reverse iteration */

extern PyTypeObject PyJudySLIntRIterKey_Type;
extern PyTypeObject PyJudySLIntRIterValue_Type;
extern PyTypeObject PyJudySLIntRIterItem_Type;
static PyObject *PyJudySLInt_riter_new(PyJudySL *, const char *,
			      PyObject *start, PyObject *end,
                              PyTypeObject *);

static PyObject *
PyJudySLInt_riter(PyObject *container)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iter",
		      NULL, NULL, &PyJudySLIntRIterKey_Type);
}

static PyObject *
PyJudySLInt_riterkeys(PyObject *container)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iterkeys",
		      NULL, NULL, &PyJudySLIntRIterKey_Type);
}

static PyObject *
PyJudySLInt_riterkeys_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iterkeys_from",
		      key, NULL, &PyJudySLIntRIterKey_Type);
}
static PyObject *
PyJudySLInt_riterkeys_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iterkeys_to",
		      NULL, key, &PyJudySLIntRIterKey_Type);
}

static PyObject *
PyJudySLInt_riterkeys_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_riter_new((PyJudySL *)container, "iterkey_range",
		      start, end, &PyJudySLIntRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudySLInt_ritervalues(PyObject *container)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "itervalues",
		      NULL, NULL, &PyJudySLIntRIterValue_Type);
}
static PyObject *
PyJudySLInt_ritervalues_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "itervalues_to",
		      key, NULL, &PyJudySLIntRIterValue_Type);

}
static PyObject *
PyJudySLInt_ritervalues_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "itervalues_to",
		      NULL, key, &PyJudySLIntRIterValue_Type);

}
static PyObject *
PyJudySLInt_ritervalues_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_riter_new((PyJudySL *)container, "itervalues_range",
		      start, end, &PyJudySLIntRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudySLInt_riteritems(PyObject *container)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iteritems",
		      NULL, NULL, &PyJudySLIntRIterItem_Type);
}
static PyObject *
PyJudySLInt_riteritems_from(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iteritems_to",
		      key, NULL, &PyJudySLIntRIterItem_Type);

}
static PyObject *
PyJudySLInt_riteritems_to(PyObject *container, PyObject *key)
{
  return PyJudySLInt_riter_new((PyJudySL *)container, "iteritems_to",
		      NULL, key, &PyJudySLIntRIterItem_Type);

}
static PyObject *
PyJudySLInt_riteritems_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLInt_riter_new((PyJudySL *)container, "iteritems_range",
		      start, end, &PyJudySLIntRIterItem_Type);

}
/* This is not a limitation in Judy per se.  It's a limitation in the      */
/* Judy modifies the string 'index' buffer in-place.  Python strings don't */
/* like that.  I could have a per-array buffer, perhaps configurable when  */
/* you create the object, or an optional per-call 'buffer' parameter for   */
/* those who want a thread-safe interface.  This works for now.            */

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudySLInt_make_2ple(uint8_t *index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = PyString_FromString((char *) index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = PyInt_FromLong((Word_t)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudySLInt_dealloc(PyJudySL* self)
{
  
  JudySLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudySLInt_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudySL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudySL *)PyObject_New(PyJudySL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  self->count = 0;
  self->max_seen = 0;
  return (PyObject *)self;
}

/* Forward declaration */
static int
PyJudySLInt_ass_sub(PyJudySL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudySLInt_Ins(PyJudySL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudySLInt_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudySLInt_delitem(PyJudySL *self, PyObject *key)
{
  char *s;

  
  if (check_string(key, &s) != 0)
      return NULL;
;

  {
  int rc;
  rc = JudySLDel(&(self->array), s, PJE0);
  if (rc == 1) {
    self->count--;
  } else if (rc != 0) {
     PyErr_SetString(PyExc_SystemError,
                     "judy error response during deletion");
  }
  return rc;
};
}

static PyObject *
PyJudySLInt_Del(PyJudySL *self, PyObject *key)
{
  int success;
  success = PyJudySLInt_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudySLInt_Get(PyJudySL *self, PyObject *key)
{
  PPvoid_t p;
  char *s;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudySLInt_get(PyJudySL *self, PyObject *args)
{
  PPvoid_t p;
  char *s;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static PyObject *
PyJudySLInt_FreeArray(PyJudySL *self)
{
  
  self->count=0;
  self->max_seen=0;
  JudySLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudySLInt_First(PyJudySL *self, PyObject *args)
{
  PPvoid_t p;
  PyObject *key=NULL;
  char *s;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key != NULL) {
    
  if (check_string(key, &s) != 0)
      return NULL;
;
    strcpy(index_buffer, s);
  } else {
    index_buffer[0] = '\0';
  }

  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLInt_make_2ple(index_buffer, p);
 }

static PyObject *
PyJudySLInt_Next(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  strcpy(index_buffer, s);

  p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudySLInt_make_2ple(index_buffer, p);
}

static PyObject *
PyJudySLInt_Last(PyJudySL *self, PyObject *args)
{
  char *s;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key != NULL) {
    
  if (check_string(key, &s) != 0)
      return NULL;
;
    strcpy(index_buffer, s);
  } else {
    memset(index_buffer, 255, self->max_seen);
    index_buffer[self->max_seen] = '\0';
  }

  p = JudySLLast(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLInt_make_2ple(index_buffer, p);
}

static PyObject *
PyJudySLInt_Prev(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  strcpy(index_buffer, s);
  p = JudySLPrev(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLInt_make_2ple(index_buffer, p);
}


/* Python object adapters */

static PyObject *
PyJudySLInt_keys(PyJudySL *self)
{
  PyObject *v;
  Word_t n;
  PPvoid_t p;
  int i=0;
  char *s;

  n = self->count;
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    s = index_buffer;
    PyList_SET_ITEM(v, i, 
PyString_FromString(s)
);
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;
}

static PyObject *
PyJudySLInt_values(PyJudySL *self)
{
  PyObject *v;
  Word_t n;
  PPvoid_t p;
  int i=0;

  n = self->count;
  v = PyList_New(n);
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, PyInt_FromLong((Word_t)(*p)));
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;
}

static PyObject *
PyJudySLInt_items(PyJudySL *self)
{
  PyObject *v, *tuple;
  Word_t n;
  PPvoid_t p;
  int i=0;

  n = self->count;
  v = PyList_New(n);
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudySLInt_make_2ple(index_buffer, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudySLInt_contains(PyJudySL *self, PyObject *key)
{
  char *s;
  Pvoid_t p;
  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  return p != NULL;
}

/* Meet the mapping protocol */
static int
PyJudySLInt_length(PyJudySL *self)
{
  /* XXX what if count > 2**31? */
  return self->count;
}

static PyObject *
PyJudySLInt_Count(PyJudySL *self)
{
  return PyInt_FromLong(self->count);
}

static PyObject *
PyJudySLInt_subscript(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

static int
PyJudySLInt_ass_sub(PyJudySL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudySLInt_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
  /* Add the key/value */
  char *s;
  PPvoid_t p;
  long val;

  if (check_string(key, &s) != 0)
      return -1;

  if (!PyInt_CheckExact(value)) {
      PyErr_SetString(PyExc_ValueError, "an integer value is required");
      return -1;
  }
  val = PyInt_AS_LONG(value);

  /* There's no way to tell if the returned reference is to an  */
  /* existing 0 value or to a newly allocated value.  There are */
  /* several ways to work around this.  I chose the simplest;   */
  /* check if the key already exists.  */
  p = JudySLGet(self->array, (uint8_t *)s, PJE0);
  if (p == NULL) {
      /* Not present - can add without checks */
      p = JudySLIns(&(self->array), (uint8_t *)s, PJE0);
      if (p == NULL) {
          /* This only way this can fail */
          PyErr_NoMemory();
          return -1;
      }
      *((Word_t *) p) = (Word_t) val;
      self->count++;
      if (PyString_GET_SIZE(key) > self->max_seen)
          self->max_seen = PyString_GET_SIZE(key);
  } else {
      /* Already present; replace */
      *((Word_t *) p) = (Word_t) val;

      /* No need to change self->count or max_seen */
  }
  
  return 0;


  }
}


static PyMappingMethods PyJudySLInt_as_mapping = {
  (inquiry) PyJudySLInt_length,
  (binaryfunc) PyJudySLInt_subscript,
  (objobjargproc)PyJudySLInt_ass_sub,
};

/* Hack to implement "key in array" */
static PySequenceMethods PyJudySLInt_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudySLInt_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudySLInt_methods[] = {
  {"Ins", (PyCFunction) PyJudySLInt_Ins, METH_VARARGS, 
   "insert a string and value into the array"},
  {"Del", (PyCFunction) PyJudySLInt_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudySLInt_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudySLInt_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudySLInt_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"FreeArray", (PyCFunction) PyJudySLInt_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudySLInt_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"First", (PyCFunction) PyJudySLInt_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input. "
   "If no input, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudySLInt_Next, METH_O,
   "the next (key, value) tuple where the key is after the input.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudySLInt_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudySLInt_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input.  If "
   "there are no earlier tuples, raises StopIteration"},

  {"keys", (PyCFunction) PyJudySLInt_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudySLInt_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudySLInt_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudySLInt_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudySLInt_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudySLInt_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudySLInt_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input and going up "
   "to but not including the second"},

  {"itervalues", (PyCFunction) PyJudySLInt_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudySLInt_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input"},
  {"itervalues_to", (PyCFunction) PyJudySLInt_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input"},
  {"itervalues_range", (PyCFunction) PyJudySLInt_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudySLInt_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudySLInt_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input"},
  {"iteritems_to", (PyCFunction) PyJudySLInt_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input"},
  {"iteritems_range", (PyCFunction) PyJudySLInt_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input and going up to but not including the second input"},

  {"riterkeys", (PyCFunction) PyJudySLInt_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudySLInt_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudySLInt_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudySLInt_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudySLInt_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudySLInt_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input"},
  {"ritervalues_to", (PyCFunction) PyJudySLInt_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input"},
  {"ritervalues_range", (PyCFunction) PyJudySLInt_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudySLInt_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudySLInt_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input"},
  {"riteritems_to", (PyCFunction) PyJudySLInt_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input"},
  {"riteritems_range", (PyCFunction) PyJudySLInt_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input and going down to but not including the second input"},

  {"__reversed__", (PyCFunction) PyJudySLInt_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  
  {NULL}
};

/* PyJudySLInt */
static PyTypeObject PyJudySLIntType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudySLInt",             /*tp_name*/
    sizeof(PyJudySL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudySLInt_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudySLInt_as_sequence,                         /*tp_as_sequence*/
    &PyJudySLInt_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudySL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudySLInt_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudySLInt_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudySLInt_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudySLInt_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  PyObject *result;  /* reusable result tuple for iteritems */
  PyObject *end;
  const char *end_s;
  PyJudySL *container;   /* Set to NULL when iterator is exhausted */
  uint8_t iter_buffer[MAX_STRING_LEN];
} PyJudySLInt_iterobject;

static PyObject *
PyJudySLInt_iter_new(PyJudySL *container, const char *name,
	     PyObject *start, PyObject *end,
	     PyTypeObject *itertype)
{
  PyJudySLInt_iterobject *it;
  char *start_s=NULL, *end_s=NULL;

  if ((start != NULL) && (check_string(start, &start_s) != 0))
    return NULL;
  if ((end != NULL) && (check_string(end, &end_s) != 0))
    return NULL;

  it = PyObject_New(PyJudySLInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->iter_buffer[MAX_STRING_LEN] = '\0';
  if (start != NULL) {
    strcpy(it->iter_buffer, start_s);
  } else {
    it->iter_buffer[0] = '\0';
  }

  it->found_first = 0;
  it->end = end;
  if (end)
    Py_INCREF(end);
  it->end_s = end_s;
  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudySLIntIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudySLInt_iter_dealloc(PyJudySLInt_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  Py_XDECREF(it->end);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudySLIntIter_iternextkey(PyJudySLInt_iterobject *it)
{
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  s = it->iter_buffer;
  return 
PyString_FromString(s)
;
}

PyTypeObject PyJudySLIntIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-keyiterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudySLIntIter_iternextvalue(PyJudySLInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudySLIntIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-valueiterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudySLIntIter_iternextitem(PyJudySLInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or-*/
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  s = it->iter_buffer;
  key = 
PyString_FromString(s)
;
  if (!key)
    return NULL;
  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudySLIntIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-itemiterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudySLInt_riter_new(PyJudySL *container, const char *name,
	      PyObject *start, PyObject *end,
	      PyTypeObject *itertype)
{
  PyJudySLInt_iterobject *it;
  char *start_s, *end_s=NULL;

  if ((start != NULL) && (check_string(start, &start_s) != 0))
    return NULL;
  if ((end != NULL) && (check_string(end, &end_s) != 0))
    return NULL;

  it = PyObject_New(PyJudySLInt_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->iter_buffer[container->max_seen] = '\0';
  if (start != NULL) {
    strcpy(it->iter_buffer, start_s);
  } else {
    memset(it->iter_buffer, 255, container->max_seen);
  }
  it->found_first = 0;
  it->end = end;
  if (end)
    Py_INCREF(end);
  it->end_s = end_s;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudySLIntRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudySLIntRIter_iternextkey(PyJudySLInt_iterobject *it)
{
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  s = it->iter_buffer;
  return 
PyString_FromString(s)
;
}

PyTypeObject PyJudySLIntRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-keyriterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudySLIntRIter_iternextvalue(PyJudySLInt_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return PyInt_FromLong((Word_t)(*p));
}

PyTypeObject PyJudySLIntRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-valueiterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudySLIntRIter_iternextitem(PyJudySLInt_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  s = it->iter_buffer;
  key = 
PyString_FromString(s)
;
  if (!key)
    return NULL;

  value = PyInt_FromLong((Word_t)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudySLIntRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-itemriterator",              /* tp_name */
        sizeof(PyJudySLInt_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLInt_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLIntRIter_iternextitem,    /* tp_iternext */
};

/***************** PyJudySLObj **************/
/* Forward declarations for forward iteration */

extern PyTypeObject PyJudySLObjIterKey_Type;
extern PyTypeObject PyJudySLObjIterValue_Type;
extern PyTypeObject PyJudySLObjIterItem_Type;
static PyObject *PyJudySLObj_iter_new(PyJudySL *, const char *,
			      PyObject *start, PyObject *end,
                              PyTypeObject *);

static PyObject *
PyJudySLObj_iter(PyObject *container)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iter",
		      NULL, NULL, &PyJudySLObjIterKey_Type);
}

static PyObject *
PyJudySLObj_iterkeys(PyObject *container)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iterkeys",
		      NULL, NULL, &PyJudySLObjIterKey_Type);
}

static PyObject *
PyJudySLObj_iterkeys_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iterkeys_from",
		      key, NULL, &PyJudySLObjIterKey_Type);
}
static PyObject *
PyJudySLObj_iterkeys_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iterkeys_to",
		      NULL, key, &PyJudySLObjIterKey_Type);
}

static PyObject *
PyJudySLObj_iterkeys_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_iter_new((PyJudySL *)container, "iterkey_range",
		      start, end, &PyJudySLObjIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudySLObj_itervalues(PyObject *container)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "itervalues",
		      NULL, NULL, &PyJudySLObjIterValue_Type);
}
static PyObject *
PyJudySLObj_itervalues_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "itervalues_to",
		      key, NULL, &PyJudySLObjIterValue_Type);

}
static PyObject *
PyJudySLObj_itervalues_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "itervalues_to",
		      NULL, key, &PyJudySLObjIterValue_Type);

}
static PyObject *
PyJudySLObj_itervalues_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_iter_new((PyJudySL *)container, "itervalues_range",
		      start, end, &PyJudySLObjIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudySLObj_iteritems(PyObject *container)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iteritems",
		      NULL, NULL, &PyJudySLObjIterItem_Type);
}
static PyObject *
PyJudySLObj_iteritems_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iteritems_to",
		      key, NULL, &PyJudySLObjIterItem_Type);

}
static PyObject *
PyJudySLObj_iteritems_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_iter_new((PyJudySL *)container, "iteritems_to",
		      NULL, key, &PyJudySLObjIterItem_Type);

}
static PyObject *
PyJudySLObj_iteritems_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_iter_new((PyJudySL *)container, "iteritems_range",
		      start, end, &PyJudySLObjIterItem_Type);

}
/* Forward declarations for reverse iteration */

extern PyTypeObject PyJudySLObjRIterKey_Type;
extern PyTypeObject PyJudySLObjRIterValue_Type;
extern PyTypeObject PyJudySLObjRIterItem_Type;
static PyObject *PyJudySLObj_riter_new(PyJudySL *, const char *,
			      PyObject *start, PyObject *end,
                              PyTypeObject *);

static PyObject *
PyJudySLObj_riter(PyObject *container)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iter",
		      NULL, NULL, &PyJudySLObjRIterKey_Type);
}

static PyObject *
PyJudySLObj_riterkeys(PyObject *container)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iterkeys",
		      NULL, NULL, &PyJudySLObjRIterKey_Type);
}

static PyObject *
PyJudySLObj_riterkeys_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iterkeys_from",
		      key, NULL, &PyJudySLObjRIterKey_Type);
}
static PyObject *
PyJudySLObj_riterkeys_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iterkeys_to",
		      NULL, key, &PyJudySLObjRIterKey_Type);
}

static PyObject *
PyJudySLObj_riterkeys_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_riter_new((PyJudySL *)container, "iterkey_range",
		      start, end, &PyJudySLObjRIterKey_Type);
}

/**** itervalues ****/

static PyObject *
PyJudySLObj_ritervalues(PyObject *container)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "itervalues",
		      NULL, NULL, &PyJudySLObjRIterValue_Type);
}
static PyObject *
PyJudySLObj_ritervalues_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "itervalues_to",
		      key, NULL, &PyJudySLObjRIterValue_Type);

}
static PyObject *
PyJudySLObj_ritervalues_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "itervalues_to",
		      NULL, key, &PyJudySLObjRIterValue_Type);

}
static PyObject *
PyJudySLObj_ritervalues_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_riter_new((PyJudySL *)container, "itervalues_range",
		      start, end, &PyJudySLObjRIterValue_Type);

}

/********* iteritems ***********/

static PyObject *
PyJudySLObj_riteritems(PyObject *container)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iteritems",
		      NULL, NULL, &PyJudySLObjRIterItem_Type);
}
static PyObject *
PyJudySLObj_riteritems_from(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iteritems_to",
		      key, NULL, &PyJudySLObjRIterItem_Type);

}
static PyObject *
PyJudySLObj_riteritems_to(PyObject *container, PyObject *key)
{
  return PyJudySLObj_riter_new((PyJudySL *)container, "iteritems_to",
		      NULL, key, &PyJudySLObjRIterItem_Type);

}
static PyObject *
PyJudySLObj_riteritems_range(PyObject *container, PyObject *args)
{
  PyObject *start, *end;
  if (!PyArg_UnpackTuple(args, "iterkeys_range", 2, 2, &start, &end))
    return NULL;
  return PyJudySLObj_riter_new((PyJudySL *)container, "iteritems_range",
		      start, end, &PyJudySLObjRIterItem_Type);

}
/* This is not a limitation in Judy per se.  It's a limitation in the      */
/* Judy modifies the string 'index' buffer in-place.  Python strings don't */
/* like that.  I could have a per-array buffer, perhaps configurable when  */
/* you create the object, or an optional per-call 'buffer' parameter for   */
/* those who want a thread-safe interface.  This works for now.            */

/* Helper function to make a 2-element tuple from key/value */

static PyObject *
PyJudySLObj_make_2ple(uint8_t *index, PPvoid_t p)
{
  PyObject *tuple;
  PyObject *key;
  PyObject *value;

  tuple = PyTuple_New(2);
  if (tuple == NULL)
    return NULL;

  key = PyString_FromString((char *) index);
  if (key == NULL) {
    Py_DECREF(tuple);
    return NULL;
  }

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (value == NULL) {
    Py_DECREF(key);
    Py_DECREF(tuple);
    return NULL;
  }
  PyTuple_SET_ITEM(tuple, 0, key);
  PyTuple_SET_ITEM(tuple, 1, value);
  return tuple;
}

static void
PyJudySLObj_dealloc(PyJudySL* self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    index_buffer[0] = '\0';
    p=JudySLFirst(self->array, index_buffer, PJE0);
    while (p) {
      obj = *((PyObject **) p);
      Py_DECREF(obj);
      p = JudySLNext(self->array, index_buffer, PJE0);
    }
}
  JudySLFreeArray( &(self->array), PJE0);
  PyObject_Del((PyObject *)self);
}

static PyObject *
PyJudySLObj_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
  PyJudySL *self;
  /* What is the right way to check for no arguments? */
  if (!PyArg_UnpackTuple(args, "new", 0, 0))
    return NULL;

  self = (PyJudySL *)PyObject_New(PyJudySL, type);
  if (self == NULL)
    return NULL;

  self->array = NULL;
  self->count = 0;
  self->max_seen = 0;
  return (PyObject *)self;
}

/* Forward declaration */
static int
PyJudySLObj_ass_sub(PyJudySL *self, PyObject *key, PyObject *value);

static PyObject *
PyJudySLObj_Ins(PyJudySL *self, PyObject *args)
{
  PyObject *key, *value;
  int status;
  if (!PyArg_UnpackTuple(args, "Ins", 2, 2, &key, &value))
    return NULL;

  status = PyJudySLObj_ass_sub(self, key, value);
  if (status == 0) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  return NULL;
}


static int
PyJudySLObj_delitem(PyJudySL *self, PyObject *key)
{
  char *s;

  
  if (check_string(key, &s) != 0)
      return NULL;
;

  {
  PPvoid_t p;
  /* Need to decref the object if it is present so */
  /* check if it exists. */
  p = JudySLGet(self->array, (uint8_t *)s, PJE0);
  if (p == NULL) {
      /* Not present, cannot delete. */
      return 0;
  }
  /* Found; delete at will */
  Py_DECREF(*((PyObject **) p));
  JudySLDel(&(self->array), s, PJE0);
  self->count--;
  return 1;
};
}

static PyObject *
PyJudySLObj_Del(PyJudySL *self, PyObject *key)
{
  int success;
  success = PyJudySLObj_delitem(self, key);
  if (success == 0) {
    /* failed because the key does not exist */
    Py_INCREF(Py_False);
    return Py_False;
  } else if (success == 1) {
    /* successful deletion */
    Py_INCREF(Py_True);
    return Py_True;
  }
  /* Some other sort of error; exception already set */
  return NULL;
}

static PyObject *
PyJudySLObj_Get(PyJudySL *self, PyObject *key)
{
  PPvoid_t p;
  char *s;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (p == NULL) {
    /* Not present; map that to an IndexError */
    PyErr_SetObject(PyExc_IndexError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudySLObj_get(PyJudySL *self, PyObject *args)
{
  PPvoid_t p;
  char *s;
  PyObject *key, *failobj = Py_None;

  if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
    return NULL;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (p == NULL) {
    /* Not present; return the default */
    Py_INCREF(failobj);
    return failobj;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static PyObject *
PyJudySLObj_FreeArray(PyJudySL *self)
{
  {
    PPvoid_t p;
    PyObject *obj;
    index_buffer[0] = '\0';
    p=JudySLFirst(self->array, index_buffer, PJE0);
    while (p) {
      obj = *((PyObject **) p);
      Py_DECREF(obj);
      p = JudySLNext(self->array, index_buffer, PJE0);
    }
}
  self->count=0;
  self->max_seen=0;
  JudySLFreeArray( &(self->array), PJE0);
  /* not returning the size */
  Py_INCREF(Py_None);
  return Py_None;
}

/* ******** */

static PyObject *
PyJudySLObj_First(PyJudySL *self, PyObject *args)
{
  PPvoid_t p;
  PyObject *key=NULL;
  char *s;

  if (!PyArg_UnpackTuple(args, "First", 0, 1, &key))
    return NULL;
  if (key != NULL) {
    
  if (check_string(key, &s) != 0)
      return NULL;
;
    strcpy(index_buffer, s);
  } else {
    index_buffer[0] = '\0';
  }

  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLObj_make_2ple(index_buffer, p);
 }

static PyObject *
PyJudySLObj_Next(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  strcpy(index_buffer, s);

  p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }

  return PyJudySLObj_make_2ple(index_buffer, p);
}

static PyObject *
PyJudySLObj_Last(PyJudySL *self, PyObject *args)
{
  char *s;
  PPvoid_t p;
  PyObject *key = NULL;

  if (!PyArg_UnpackTuple(args, "Last", 0, 1, &key))
    return NULL;
  if (key != NULL) {
    
  if (check_string(key, &s) != 0)
      return NULL;
;
    strcpy(index_buffer, s);
  } else {
    memset(index_buffer, 255, self->max_seen);
    index_buffer[self->max_seen] = '\0';
  }

  p = JudySLLast(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLObj_make_2ple(index_buffer, p);
}

static PyObject *
PyJudySLObj_Prev(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  strcpy(index_buffer, s);
  p = JudySLPrev(self->array, (uint8_t *)index_buffer, PJE0);
  if (p == NULL) {
    PyErr_SetNone(PyExc_StopIteration);
    return NULL;
  }
  return PyJudySLObj_make_2ple(index_buffer, p);
}


/* Python object adapters */

static PyObject *
PyJudySLObj_keys(PyJudySL *self)
{
  PyObject *v;
  Word_t n;
  PPvoid_t p;
  int i=0;
  char *s;

  n = self->count;
  v = PyList_New(n);
  if (v == NULL)
    return NULL;
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of keys");
      Py_DECREF(v);
      return NULL;
    }
    s = index_buffer;
    PyList_SET_ITEM(v, i, 
PyString_FromString(s)
);
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;
}

static PyObject *
PyJudySLObj_values(PyJudySL *self)
{
  PyObject *v;
  Word_t n;
  PPvoid_t p;
  int i=0;

  n = self->count;
  v = PyList_New(n);
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of values");
      Py_DECREF(v);
      return NULL;
    }
    PyList_SET_ITEM(v, i, (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p)));
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;
}

static PyObject *
PyJudySLObj_items(PyJudySL *self)
{
  PyObject *v, *tuple;
  Word_t n;
  PPvoid_t p;
  int i=0;

  n = self->count;
  v = PyList_New(n);
  index_buffer[0] = '\0';
  p = JudySLFirst(self->array, (uint8_t *)index_buffer, PJE0);
  while (i<n) {
    if (!p) {
      PyErr_SetString(PyExc_SystemError,
		      "JudySL size changed while creating list of items");
      goto error;
    }
    tuple = PyJudySLObj_make_2ple(index_buffer, p);
    if (tuple == NULL)
      goto error;
    PyList_SET_ITEM(v, i, tuple);
    i++;
    p = JudySLNext(self->array, (uint8_t *)index_buffer, PJE0);
  }
  return v;

 error:
  Py_XDECREF(v);
  return NULL;
}

int
PyJudySLObj_contains(PyJudySL *self, PyObject *key)
{
  char *s;
  Pvoid_t p;
  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  return p != NULL;
}

/* Meet the mapping protocol */
static int
PyJudySLObj_length(PyJudySL *self)
{
  /* XXX what if count > 2**31? */
  return self->count;
}

static PyObject *
PyJudySLObj_Count(PyJudySL *self)
{
  return PyInt_FromLong(self->count);
}

static PyObject *
PyJudySLObj_subscript(PyJudySL *self, PyObject *key)
{
  char *s;
  PPvoid_t p;

  
  if (check_string(key, &s) != 0)
      return NULL;
;
  p = JudySLGet(self->array, s, PJE0);
  if (!p) {
    PyErr_SetObject(PyExc_KeyError, key);
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

static int
PyJudySLObj_ass_sub(PyJudySL *self, PyObject *key, PyObject *value)
{
  if (value == NULL) {

    int success;
    success = PyJudySLObj_delitem(self, key);
    if (success == 1) {
      return 0;
    }
    if (success == 0) {
      /* Key not found */
      PyErr_SetObject(PyExc_KeyError, key);
      return -1;
    }
    /* Some other error - exception already set */
    return -1;
      

  } else {

    
  /* Add the key/value */
  char *s;
  PPvoid_t p;

  if (check_string(key, &s) != 0)
    return -1;

  /* Go ahead and insert */
  p = JudySLIns(&(self->array), (uint8_t *)s, PJE0);

  if (*p == NULL) {
      /* No object was there - assign this one */
      *p = value;
      Py_INCREF(value);
      self->count++;
  } else {
      /* Something was already there. Assign the */
      /* new reference before removing the old.  */
      PyObject *old_obj = *p;
      Py_INCREF(value);
      *p = value;
      Py_DECREF(old_obj);
      /* self->count does not change */
  }
  if (PyString_GET_SIZE(key) > self->max_seen)
      self->max_seen = PyString_GET_SIZE(key);
  return 0;


  }
}


static PyMappingMethods PyJudySLObj_as_mapping = {
  (inquiry) PyJudySLObj_length,
  (binaryfunc) PyJudySLObj_subscript,
  (objobjargproc)PyJudySLObj_ass_sub,
};

/* Hack to implement "key in array" */
static PySequenceMethods PyJudySLObj_as_sequence = {
        0,                                      /* sq_length */
        0,                                      /* sq_concat */
        0,                                      /* sq_repeat */
        0,                                      /* sq_item */
        0,                                      /* sq_slice */
        0,                                      /* sq_ass_item */
        0,                                      /* sq_ass_slice */
        (objobjproc)PyJudySLObj_contains,               /* sq_contains */
        0,                                      /* sq_inplace_concat */
        0,                                      /* sq_inplace_repeat */
};


static PyMethodDef PyJudySLObj_methods[] = {
  {"Ins", (PyCFunction) PyJudySLObj_Ins, METH_VARARGS, 
   "insert a string and value into the array"},
  {"Del", (PyCFunction) PyJudySLObj_Del, METH_O, 
   "delete the given key; return True if a deletion occured, else False"},
  {"Get", (PyCFunction) PyJudySLObj_Get, METH_O,
   "given a key get the corresponding value; raise IndexError there is not one"},
  {"get", (PyCFunction) PyJudySLObj_get, METH_VARARGS,
   "given a key get the corresponding value; else return failobj (default failobj is None)"},
  {"Count", (PyCFunction) PyJudySLObj_Count, METH_NOARGS,
   "total number of elements in the array"},
  {"FreeArray", (PyCFunction) PyJudySLObj_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"clear", (PyCFunction) PyJudySLObj_FreeArray, METH_NOARGS,
   "free the entire array"},
  {"First", (PyCFunction) PyJudySLObj_First, METH_VARARGS,
   "the first (key, value) tuple where the key is at or after the input. "
   "If no input, returns the first tuple in the array.  If there are no "
   "later tuples, raises StopIteration"},
  {"Next", (PyCFunction) PyJudySLObj_Next, METH_O,
   "the next (key, value) tuple where the key is after the input.  If there "
   "are no later tuples, raises StopIteration"},
  {"Last", (PyCFunction) PyJudySLObj_Last, METH_VARARGS,
   "the first (key, value) tuple where the key is at or before the input. "
   "If no input, returns the last tuple in the array.  If there are no "
   "earlier tuples, raises StopIteration"},
  {"Prev", (PyCFunction) PyJudySLObj_Prev, METH_O,
   "the previous (key, value) tuple where the key is before the input.  If "
   "there are no earlier tuples, raises StopIteration"},

  {"keys", (PyCFunction) PyJudySLObj_keys, METH_NOARGS,
   "the keys as a list"},
  {"values", (PyCFunction) PyJudySLObj_values, METH_NOARGS,
   "the values as a list"},
  {"items", (PyCFunction) PyJudySLObj_items, METH_NOARGS,
   "the items as a list of (key, value) tuples"},
  {"iterkeys", (PyCFunction) PyJudySLObj_iterkeys, METH_NOARGS,
   "iterate through all keys"},
  {"iterkeys_from", (PyCFunction) PyJudySLObj_iterkeys_from, METH_O,
   "iterate through the keys starting with the given input key, going up"},
  {"iterkeys_to", (PyCFunction) PyJudySLObj_iterkeys_to, METH_O, 
   "iterate through the keys up to but not including the given input key"},
  {"iterkeys_range", (PyCFunction) PyJudySLObj_iterkeys_range, METH_VARARGS,
   "iterate through the keys starting at or after the first input and going up "
   "to but not including the second"},

  {"itervalues", (PyCFunction) PyJudySLObj_itervalues, METH_NOARGS,
   "iterate through all values"},
  {"itervalues_from", (PyCFunction) PyJudySLObj_itervalues_from, METH_O,
   "iterate through the values corresponding to keys at or after the input"},
  {"itervalues_to", (PyCFunction) PyJudySLObj_itervalues_to, METH_O,
   "iterate through the values corresponding to keys up to but not including "
   "the input"},
  {"itervalues_range", (PyCFunction) PyJudySLObj_itervalues_range, METH_VARARGS, 
   "iterate through the values corresponding to keys starting at or after the "
   "first input and going up to but not including the second"},

  {"iteritems", (PyCFunction) PyJudySLObj_iteritems, METH_NOARGS,
   "iterate through all (key,value) pairs"},
  {"iteritems_from", (PyCFunction) PyJudySLObj_iteritems_from, METH_O, 
   "iterate through the (key,value) pairs starting with the key at or after "
   "the given input"},
  {"iteritems_to", (PyCFunction) PyJudySLObj_iteritems_to, METH_O,
   "iterate through the (key,value) pairs where the key is before the input"},
  {"iteritems_range", (PyCFunction) PyJudySLObj_iteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or above "
   "the first input and going up to but not including the second input"},

  {"riterkeys", (PyCFunction) PyJudySLObj_riterkeys, METH_NOARGS, 
   "reverse iteration through all the keys"},
  {"riterkeys_from", (PyCFunction) PyJudySLObj_riterkeys_from, METH_O,
   "reverse iteration through the keys starting with the given input key, "
   "going down"},
  {"riterkeys_to", (PyCFunction) PyJudySLObj_riterkeys_to, METH_O,
   "reverse iteration through the keys down to but not including the given "
   "input key"},
  {"riterkeys_range", (PyCFunction) PyJudySLObj_riterkeys_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input "
   "and going down to but not including the second"},

  {"ritervalues", (PyCFunction) PyJudySLObj_ritervalues, METH_NOARGS,
   "reverse iteration through all values"},
  {"ritervalues_from", (PyCFunction) PyJudySLObj_ritervalues_from, METH_O,
   "reverse iteration through the values corresponding to keys at or before "
   "the input"},
  {"ritervalues_to", (PyCFunction) PyJudySLObj_ritervalues_to, METH_O, 
   "reverse iteration through the values corresponding to keys down to but "
   "not including the input"},
  {"ritervalues_range", (PyCFunction) PyJudySLObj_ritervalues_range, METH_VARARGS,
   "reverse iteration through the keys starting at or before the first input "
   "and going down to but not including the second"},

  {"riteritems", (PyCFunction) PyJudySLObj_riteritems, METH_NOARGS,
   "reverse iteration through all (key,value) pairs"},
  {"riteritems_from", (PyCFunction) PyJudySLObj_riteritems_from, METH_O,
   "reverse iteration through the (key,value) pairs starting with the "
   "key at or before the given input"},
  {"riteritems_to", (PyCFunction) PyJudySLObj_riteritems_to, METH_O, 
   "reverse iteration through the (key,value) pairs while the key is above "
   "the given input"},
  {"riteritems_range", (PyCFunction) PyJudySLObj_riteritems_range, METH_VARARGS, 
   "iterate through the (key,value) pairs starting with the key at or below "
   "the first input and going down to but not including the second input"},

  {"__reversed__", (PyCFunction) PyJudySLObj_riter, METH_NOARGS,
   "reverse iteration through the keys"},

  
  {NULL}
};

/* PyJudySLObj */
static PyTypeObject PyJudySLObjType = {
    PyObject_HEAD_INIT(NULL)
    0,                         /*ob_size*/
    "pyjudy.PyJudySLObj",             /*tp_name*/
    sizeof(PyJudySL), /*tp_basicsize*/
    0,                         /*tp_itemsize*/
    (destructor)PyJudySLObj_dealloc,                         /*tp_dealloc*/
    0,                         /*tp_print*/
    0,                         /*tp_getattr*/
    0,                         /*tp_setattr*/
    0,                         /*tp_compare*/
    0,                         /*tp_repr*/
    0,                         /*tp_as_number*/
    &PyJudySLObj_as_sequence,                         /*tp_as_sequence*/
    &PyJudySLObj_as_mapping,                         /*tp_as_mapping*/
    0,                         /*tp_hash */
    0,                         /*tp_call*/
    0,                         /*tp_str*/
    0,                         /*tp_getattro*/
    0,                         /*tp_setattro*/
    0,                         /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,        /*tp_flags*/
    "JudySL arrays",           /* tp_doc */
    0,                         /* tp_traverse */
    0,                         /* tp_clear */
    0,                         /* tp_richcompare */
    0,                         /* tp_weaklistoffset */
    PyJudySLObj_iter,                       /* tp_iter */
    0,                         /* tp_iternext */
    PyJudySLObj_methods,             /* tp_methods */
    0,             /* tp_members */
    0,                         /* tp_getset */
    0,                         /* tp_base */
    0,                         /* tp_dict */
    0,                         /* tp_descr_get */
    0,                         /* tp_descr_set */
    0,                         /* tp_dictoffset */
    0, /*(initproc)PyJudySLObj_init,*/      /* tp_init */
    0,                         /* tp_alloc */
    PyJudySLObj_new,                 /* tp_new */

};


/******* forward iteration *******/


typedef struct {
  PyObject_HEAD
  short found_first;
  PyObject *result;  /* reusable result tuple for iteritems */
  PyObject *end;
  const char *end_s;
  PyJudySL *container;   /* Set to NULL when iterator is exhausted */
  uint8_t iter_buffer[MAX_STRING_LEN];
} PyJudySLObj_iterobject;

static PyObject *
PyJudySLObj_iter_new(PyJudySL *container, const char *name,
	     PyObject *start, PyObject *end,
	     PyTypeObject *itertype)
{
  PyJudySLObj_iterobject *it;
  char *start_s=NULL, *end_s=NULL;

  if ((start != NULL) && (check_string(start, &start_s) != 0))
    return NULL;
  if ((end != NULL) && (check_string(end, &end_s) != 0))
    return NULL;

  it = PyObject_New(PyJudySLObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->iter_buffer[MAX_STRING_LEN] = '\0';
  if (start != NULL) {
    strcpy(it->iter_buffer, start_s);
  } else {
    it->iter_buffer[0] = '\0';
  }

  it->found_first = 0;
  it->end = end;
  if (end)
    Py_INCREF(end);
  it->end_s = end_s;
  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudySLObjIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

static void
PyJudySLObj_iter_dealloc(PyJudySLObj_iterobject *it)
{
  Py_XDECREF(it->container);
  Py_XDECREF(it->result);
  Py_XDECREF(it->end);
  PyObject_Del(it);
}

/***************************/

static PyObject *PyJudySLObjIter_iternextkey(PyJudySLObj_iterobject *it)
{
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  s = it->iter_buffer;
  return 
PyString_FromString(s)
;
}

PyTypeObject PyJudySLObjIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-keyiterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudySLObjIter_iternextvalue(PyJudySLObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudySLObjIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-valueiterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudySLObjIter_iternextitem(PyJudySLObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudySLNext(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLFirst(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or-*/
             /* Reached the upper limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)>=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  s = it->iter_buffer;
  key = 
PyString_FromString(s)
;
  if (!key)
    return NULL;
  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudySLObjIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-itemiterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjIter_iternextitem,    /* tp_iternext */
};

/******* reverse iteration *******/

static PyObject *
PyJudySLObj_riter_new(PyJudySL *container, const char *name,
	      PyObject *start, PyObject *end,
	      PyTypeObject *itertype)
{
  PyJudySLObj_iterobject *it;
  char *start_s, *end_s=NULL;

  if ((start != NULL) && (check_string(start, &start_s) != 0))
    return NULL;
  if ((end != NULL) && (check_string(end, &end_s) != 0))
    return NULL;

  it = PyObject_New(PyJudySLObj_iterobject, itertype);
  if (it == NULL)
    return NULL;

  it->iter_buffer[container->max_seen] = '\0';
  if (start != NULL) {
    strcpy(it->iter_buffer, start_s);
  } else {
    memset(it->iter_buffer, 255, container->max_seen);
  }
  it->found_first = 0;
  it->end = end;
  if (end)
    Py_INCREF(end);
  it->end_s = end_s;

  Py_INCREF(container);
  it->container = container;

  if (itertype == &PyJudySLObjRIterItem_Type) {
    it->result = PyTuple_New(2);
    if (it->result == NULL) {
      Py_DECREF(it);
      return NULL;
    }
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 0, Py_None);
    Py_INCREF(Py_None);
    PyTuple_SET_ITEM(it->result, 1, Py_None);
  } else
    it->result = NULL;
  
  return (PyObject *)it;
}

/***************************/

static PyObject *PyJudySLObjRIter_iternextkey(PyJudySLObj_iterobject *it)
{
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  s = it->iter_buffer;
  return 
PyString_FromString(s)
;
}

PyTypeObject PyJudySLObjRIterKey_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-keyriterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjRIter_iternextkey,    /* tp_iternext */
};


static PyObject *PyJudySLObjRIter_iternextvalue(PyJudySLObj_iterobject *it)
{
  PPvoid_t p;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) { 
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }
  return (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
}

PyTypeObject PyJudySLObjRIterValue_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-valueiterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjRIter_iternextvalue,    /* tp_iternext */
};




static PyObject *PyJudySLObjRIter_iternextitem(PyJudySLObj_iterobject *it)
{
  PyObject *key, *value, *result;
  PPvoid_t p;
  char *s;
  
  if (it->container == NULL)
    return NULL;   /* container previously exhausted */
  result = it->result;
  
  if (it->found_first) {
    p = JudySLPrev(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  } else {
    it->found_first = 1;
    p = JudySLLast(it->container->array, (uint8_t *)it->iter_buffer, PJE0);
  }
  if (!p ||  /* Reached the end -or- */
             /* Reached the lower limit */ 
      (it->end && strcmp(it->iter_buffer, it->end_s)<=0)
      ) {
    Py_DECREF(it->container);
    it->container = NULL;
    return NULL;
  }

  /* Performance tweak by reusing a tuple not used by anyone else */
  if (result->ob_refcnt == 1) {
    Py_INCREF(result);
    Py_DECREF(PyTuple_GET_ITEM(result, 0));
    Py_DECREF(PyTuple_GET_ITEM(result, 1));
  } else {
    result = PyTuple_New(2);
    if (result == NULL)
      return NULL;
  }
  s = it->iter_buffer;
  key = 
PyString_FromString(s)
;
  if (!key)
    return NULL;

  value = (Py_INCREF((PyObject *)(*p)), (PyObject *)(*p));
  if (!value) {
    Py_DECREF(key);
    return NULL;
  }

  PyTuple_SET_ITEM(result, 0, key);
  PyTuple_SET_ITEM(result, 1, value);
  return result;
}

PyTypeObject PyJudySLObjRIterItem_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,                                      /* ob_size */
        "pyjudysl-itemriterator",              /* tp_name */
        sizeof(PyJudySLObj_iterobject),                 /* tp_basicsize */
        0,                                      /* tp_itemsize */
        /* methods */
        (destructor)PyJudySLObj_iter_dealloc,           /* tp_dealloc */
        0,                                      /* tp_print */
        0,                                      /* tp_getattr */
        0,                                      /* tp_setattr */
        0,                                      /* tp_compare */
        0,                                      /* tp_repr */
        0,                                      /* tp_as_number */
        0, /*&dictiter_as_sequence,*/                  /* tp_as_sequence */
        0,                                      /* tp_as_mapping */
        0,                                      /* tp_hash */
        0,                                      /* tp_call */
        0,                                      /* tp_str */
        PyObject_GenericGetAttr,                /* tp_getattro */
        0,                                      /* tp_setattro */
        0,                                      /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT,                     /* tp_flags */
        0,                                      /* tp_doc */
        0,                                      /* tp_traverse */
        0,                                      /* tp_clear */
        0,                                      /* tp_richcompare */
        0,                                      /* tp_weaklistoffset */
        PyObject_SelfIter,                      /* tp_iter */
        (iternextfunc)PyJudySLObjRIter_iternextitem,    /* tp_iternext */
};





/****** Module initialization ****/

static PyMethodDef module_methods[] = {
  {NULL}  /* Sentinel */
};

PyMODINIT_FUNC
initpyjudy(void)
{
  PyObject *m;

  if (PyType_Ready(&PyJudyLIntIntType) < 0) {
    return ;
    }
  if (PyType_Ready(&PyJudyLIntObjType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudyLObjObjType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudyLObjIntType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudy1IntType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudy1ObjType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudySLIntType) < 0) {
    return ;
  }
  if (PyType_Ready(&PyJudySLObjType) < 0) {
    return ;
  }
  m = Py_InitModule3("pyjudy", module_methods,
	 	     "pyjudy module docstring");

  Py_INCREF(&PyJudyLIntIntType);
  Py_INCREF(&PyJudyLIntObjType);
  Py_INCREF(&PyJudyLObjObjType);
  Py_INCREF(&PyJudyLObjIntType);
  Py_INCREF(&PyJudy1IntType);
  Py_INCREF(&PyJudy1ObjType);
  Py_INCREF(&PyJudySLIntType);
  Py_INCREF(&PyJudySLObjType);

  PyModule_AddObject(m, "JudyLIntInt", (PyObject *)&PyJudyLIntIntType);
  PyModule_AddObject(m, "JudyLIntObj", (PyObject *)&PyJudyLIntObjType);
  PyModule_AddObject(m, "JudyLObjObj", (PyObject *)&PyJudyLObjObjType);
  PyModule_AddObject(m, "JudyLObjInt", (PyObject *)&PyJudyLObjIntType);
  PyModule_AddObject(m, "Judy1Int", (PyObject *)&PyJudy1IntType);
  PyModule_AddObject(m, "Judy1Obj", (PyObject *)&PyJudy1ObjType);
  PyModule_AddObject(m, "JudySLInt", (PyObject *)&PyJudySLIntType);
  PyModule_AddObject(m, "JudySLObj", (PyObject *)&PyJudySLObjType);

  PyModule_AddStringConstant(m, "__version__", "1.0");
  PyModule_AddIntConstant(m, "MAX_STRING_LEN", MAX_STRING_LEN);
}
